/*
 * NanoSTL v0.2.0
 * Generated: 2020-11-13 17:44:18.995076
 * ----------------------------------------------------------
 * The MIT License (MIT)
 *
 * Copyright (c) 2017-2020 Light Transport Entertainment, Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
#ifndef NANOSTL_SINGLE_INCLUDE_H_
#define NANOSTL_SINGLE_INCLUDE_H_
#ifndef NANOSTL_H_
#define NANOSTL_H_

// #included from: nanovector.h

#define NANOSTL_VECTOR_H_

// #included from: nanocommon.h

#define NANOSTL_COMMON_H_

#ifdef __CUDACC__
#define NANOSTL_DEVICE_QUAL __device__
#define NANOSTL_HOST_QUAL __host__
#define NANOSTL_HOST_AND_DEVICE_QUAL __host__ __device__
#define NANOSTL_GLOBAL_QUAL __global__
#define NANOSTL_CONSTANT_QUAL __constant__
#else
#define NANOSTL_DEVICE_QUAL
#define NANOSTL_HOST_QUAL
#define NANOSTL_HOST_AND_DEVICE_QUAL
#define NANOSTL_GLOBAL_QUAL
#define NANOSTL_CONSTANT_QUAL
#endif

// TODO(LTE): Implement
#ifndef _NANOSTL_TEMPLATE_VIS
#define _NANOSTL_TEMPLATE_VIS
#endif

namespace nanostl {

// In BigEndian architecture, must define NANOSTL_BIG_ENDIAN explicitly at the
// moment.

namespace {

union IEEE754Float {
  float f;
  unsigned int ui;
  int i;
  struct {
#if defined(NANOSTL_BIG_ENDIAN)
    unsigned int sign : 1;
    unsigned int exponent : 8;
    unsigned int mantissa : 23;
#else
    unsigned int mantissa : 23;
    unsigned int exponent : 8;
    unsigned int sign : 1;
#endif
  } bits;
};

union IEEE754Double {
  double f;
  unsigned long long ull;
  long long ll;
  struct {
#if defined(NANOSTL_BIG_ENDIAN)
    unsigned long long sign : 1;
    unsigned long long exponent : 11;
    unsigned long long mantissa : 52;
#else
    unsigned long long mantissa : 52;
    unsigned long long exponent : 11;
    unsigned long long sign : 1;
#endif
  } bits;
};

using size_t = unsigned long long;

} // namespace

}  // namespace nanostl

// #included from: nanoallocator.h

#define NANOSTL_ALLOCATOR_H_

#ifdef NANOSTL_DEBUG
#if !defined(__CUDACC__)
#include <iostream>
#endif
#endif

namespace nanostl {

typedef unsigned long long size_type;

#ifdef __clang__
#pragma clang diagnostic push
#if __has_warning("-Wzero-as-null-pointer-constant")
#pragma clang diagnostic ignored "-Wzero-as-null-pointer-constant"
#endif
#endif

///
/// allocator class implementaion without libc function
///
template <typename T>
class allocator {
 public:
  typedef T value_type;
  typedef T* pointer;
  typedef const T* const_pointer;
  typedef T& reference;
  typedef const T& const_reference;

  NANOSTL_HOST_AND_DEVICE_QUAL allocator() {}

  NANOSTL_HOST_AND_DEVICE_QUAL T* allocate(size_type n, const void* hint = 0) {
    (void)hint;  // Ignore `hint' for a while.
    if (n < 1) {
      return 0;
    }

#ifdef NANOSTL_DEBUG
#if defined(__CUDACC__)
    printf("allocator::allocate: %u\n", n);
#else
    std::cerr << "allocator::allocate: n " << n << std::endl;
#endif
#endif

    return new T[n];
  }

  NANOSTL_HOST_AND_DEVICE_QUAL void deallocate(T* p, size_type n) {
    (void)n;
    delete[] p;
  }

 private:
};

#ifdef __clang__
#pragma clang diagnostic pop
#endif

}  // namespace nanostl

#ifdef NANOSTL_DEBUG
#include <iostream>
#endif

namespace nanostl {

#ifdef __clang__
#pragma clang diagnostic push
#if __has_warning("-Wzero-as-null-pointer-constant")
#pragma clang diagnostic ignored "-Wzero-as-null-pointer-constant"
#endif
#if __has_warning("-Wunused-template")
#pragma clang diagnostic ignored "-Wunused-template"
#endif
#endif

// TODO(LTE): Support allocator.
template <class T, class Allocator = nanostl::allocator<T> >
class vector {
 public:
  typedef T value_type;
  typedef T& reference;
  typedef const T& const_reference;
  typedef T* pointer;
  typedef const T* const_pointer;
  typedef pointer iterator;
  typedef const_pointer const_iterator;
  typedef Allocator allocator_type;

  NANOSTL_HOST_AND_DEVICE_QUAL vector() : elements_(0), capacity_(0), size_(0) {}

  NANOSTL_HOST_AND_DEVICE_QUAL vector(const vector& rhs) {
    __initialize();
    assign(rhs.begin(), rhs.end());
  }

  NANOSTL_HOST_AND_DEVICE_QUAL ~vector() {
    allocator_type allocator;
    if (elements_) {
      allocator.deallocate(elements_, capacity_);
    }
  }

  reference at(size_type pos) {
    // TODO(LTE): out-of-range check.
    return elements_[pos];
  }

  const_reference at(size_type pos) const {
    // TODO(LTE): out-of-range check.
    return elements_[pos];
  }

  NANOSTL_HOST_AND_DEVICE_QUAL void resize(size_type count) {
    if (count < 1) {
      return;
    }

    if (count > capacity()) {
      // TODO(LTE): Use memcpy() or realloc() like functionality to speed up
      // resizing.
      size_type n = (count > recommended_size()) ? count : recommended_size();
#ifdef NANOSTL_DEBUG
      std::cout << "vector::resize: count " << count << ", capacity "
                << capacity() << ", recommended_size " << recommended_size()
                << ", n " << n << std::endl;
#endif
      allocator_type allocator;

      value_type* new_elements = allocator.allocate(n);
      size_type new_capacity = n;

      for (size_type i = 0; i < size(); i++) {
        new_elements[i] = elements_[i];
      }

      // delete old buffer
      allocator.deallocate(elements_, capacity_);

      elements_ = new_elements;
      capacity_ = new_capacity;
    }

    size_ = count;
  }

  NANOSTL_HOST_AND_DEVICE_QUAL void push_back(const value_type& val) {
    resize(size() + 1);
    elements_[size_ - 1] = val;
  }

  // void push_back(value_type &val); // C++11

  NANOSTL_HOST_AND_DEVICE_QUAL bool empty() const { return size_ == 0; }

  NANOSTL_HOST_AND_DEVICE_QUAL size_type size() const { return size_; }

  NANOSTL_HOST_AND_DEVICE_QUAL void clear() { size_ = 0; }

  NANOSTL_HOST_AND_DEVICE_QUAL size_type capacity() const { return capacity_; }

  NANOSTL_HOST_AND_DEVICE_QUAL reference operator[](size_type pos) { return elements_[pos]; }

  NANOSTL_HOST_AND_DEVICE_QUAL const_reference operator[](size_type pos) const { return elements_[pos]; }

  NANOSTL_HOST_AND_DEVICE_QUAL pointer data() { return elements_; }

  NANOSTL_HOST_AND_DEVICE_QUAL vector& operator=(const vector& rhs);
  NANOSTL_HOST_AND_DEVICE_QUAL vector& operator+=(const vector& rhs);

  inline iterator begin(void) const { return elements_ + 0; }

  inline iterator end(void) const { return elements_ + size_; }

  inline void pop_back() {
    if (size_ < 1) {
      // this should be undefined behavior
    }
    size_--;
  }

  inline iterator erase(iterator pos) {
    while ((pos + 1) != end()) {
      (*pos) = *(pos + 1);
      pos++;
    }
    size_--;

    return pos;
  }

  template <class InputIterator>
  void assign(InputIterator first, InputIterator last) {
    clear();
    for (; first != last; ++first) {
      push_back(*first);
    }
  }

  void swap(vector& x) {
    __swap(elements_, x.elements_);
    __swap(capacity_, x.capacity_);
    __swap(size_, x.size_);
  }

 private:
  NANOSTL_HOST_AND_DEVICE_QUAL void __initialize() {
    size_ = 0;
    capacity_ = 0;
    elements_ = 0;
  }

  template <class Ty>
  inline void __swap(Ty& x, Ty& y) {
    Ty c(x);
    x = y;
    y = c;
  }

  NANOSTL_HOST_AND_DEVICE_QUAL size_type recommended_size() const {
    // Simply use twice as large.
    size_type s = 2 * capacity();
    return s;
  }

  T* elements_;
  size_type capacity_;
  size_type size_;
};

template <class T, class Allocator>
inline vector<T, Allocator>& vector<T, Allocator>::operator=(
    const vector<T, Allocator>& rhs) {
  if (this != &rhs) {
    assign(rhs.begin(), rhs.end());
  }
  return *this;
}

#ifdef __clang__
#pragma clang diagnostic pop
#endif

}  // namespace nanostl

// #included from: nanostring.h

#define NANOSTL_STRING_H_

// #included from: __nanostrutil.h

#define NANOSTL___STRUTIL_H_

// #included from: nanocstdint.h

#define NANOSTL_CSTDINT_H_

namespace nanostl {

// Assume LLP64 or LP64 data model.
// Assume compiler interprets 'int' as 32bit
// Assume compiler interprets 'long long' as 64bit

typedef unsigned char uint8_t;
typedef unsigned short uint16_t;
typedef unsigned int uint32_t;
typedef unsigned long long uint64_t;

typedef char int8_t;
typedef short int16_t;
typedef int int32_t;
typedef long long int64_t;

}  // namespace nanostl

// #included from: nanocstring.h

#define NANOSTL_CSTRING_H_

namespace nanostl {

// Naiive implementation of memcpy
NANOSTL_HOST_AND_DEVICE_QUAL
inline void *memcpy(void *dest, const void *src, unsigned long long num)
{
  unsigned char *d_ptr = reinterpret_cast<unsigned char *>(dest);
  const unsigned char *s_ptr = reinterpret_cast<const unsigned char *>(src);

  for (unsigned long long i = 0; i < num; i++) {
    d_ptr[i] = s_ptr[i];
  }

  return dest;
}

}  // namespace nanostl

// #included from: nanocassert.h

#define NANOSTL_CASSERT_H_

#ifdef __CUDACC__
#include <assert.h>
#else
// TODO(LTE): Delegate `assert` implementation when the backend c library or equivalent library supports it.
#define assert(x)
#endif

namespace nanostl {

namespace ryu {

// ==== Ryu =================================================================
//
//
// Copyright 2018 Ulf Adams
//
// The contents of this file may be used under the terms of the Apache License,
// Version 2.0.
//
//    (See accompanying file LICENSE-Apache or copy at
//     http://www.apache.org/licenses/LICENSE-2.0)
//
// Alternatively, the contents of this file may be used under the terms of
// the Boost Software License, Version 1.0.
//    (See accompanying file LICENSE-Boost or copy at
//     https://www.boost.org/LICENSE_1_0.txt)
//
// Unless required by applicable law or agreed to in writing, this software
// is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
// KIND, either express or implied.
//
#define RYU_FLOAT_MANTISSA_BITS 23
#define RYU_FLOAT_EXPONENT_BITS 8
#define RYU_FLOAT_BIAS 127
#define RYU_FLOAT_EXPONENT_BIAS 127

#define RYU_DOUBLE_MANTISSA_BITS 52
#define RYU_DOUBLE_EXPONENT_BITS 11
#define RYU_DOUBLE_BIAS 1023
#define RYU_DOUBLE_EXPONENT_BIAS 1023

#if defined(RYU_OPTIMIZE_SIZE)
#error
#else
// #included from: ryu/d2s_full_table.h
// Copyright 2018 Ulf Adams
//
// The contents of this file may be used under the terms of the Apache License,
// Version 2.0.
//
//    (See accompanying file LICENSE-Apache or copy at
//     http://www.apache.org/licenses/LICENSE-2.0)
//
// Alternatively, the contents of this file may be used under the terms of
// the Boost Software License, Version 1.0.
//    (See accompanying file LICENSE-Boost or copy at
//     https://www.boost.org/LICENSE_1_0.txt)
//
// Unless required by applicable law or agreed to in writing, this software
// is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
// KIND, either express or implied.
#ifndef RYU_D2S_FULL_TABLE_H
#define RYU_D2S_FULL_TABLE_H

// These tables are generated by PrintDoubleLookupTable.
#define RYU_DOUBLE_POW5_INV_BITCOUNT 125
#define RYU_DOUBLE_POW5_BITCOUNT 125

#define RYU_DOUBLE_POW5_INV_TABLE_SIZE 342
#define RYU_DOUBLE_POW5_TABLE_SIZE 326

// Use global address space to save constant memory
NANOSTL_GLOBAL_QUAL NANOSTL_CONSTANT_QUAL
static const uint64_t DOUBLE_POW5_INV_SPLIT[RYU_DOUBLE_POW5_INV_TABLE_SIZE][2] = {
  {                    1u, 2305843009213693952u }, { 11068046444225730970u, 1844674407370955161u },
  {  5165088340638674453u, 1475739525896764129u }, {  7821419487252849886u, 1180591620717411303u },
  {  8824922364862649494u, 1888946593147858085u }, {  7059937891890119595u, 1511157274518286468u },
  { 13026647942995916322u, 1208925819614629174u }, {  9774590264567735146u, 1934281311383406679u },
  { 11509021026396098440u, 1547425049106725343u }, { 16585914450600699399u, 1237940039285380274u },
  { 15469416676735388068u, 1980704062856608439u }, { 16064882156130220778u, 1584563250285286751u },
  {  9162556910162266299u, 1267650600228229401u }, {  7281393426775805432u, 2028240960365167042u },
  { 16893161185646375315u, 1622592768292133633u }, {  2446482504291369283u, 1298074214633706907u },
  {  7603720821608101175u, 2076918743413931051u }, {  2393627842544570617u, 1661534994731144841u },
  { 16672297533003297786u, 1329227995784915872u }, { 11918280793837635165u, 2126764793255865396u },
  {  5845275820328197809u, 1701411834604692317u }, { 15744267100488289217u, 1361129467683753853u },
  {  3054734472329800808u, 2177807148294006166u }, { 17201182836831481939u, 1742245718635204932u },
  {  6382248639981364905u, 1393796574908163946u }, {  2832900194486363201u, 2230074519853062314u },
  {  5955668970331000884u, 1784059615882449851u }, {  1075186361522890384u, 1427247692705959881u },
  { 12788344622662355584u, 2283596308329535809u }, { 13920024512871794791u, 1826877046663628647u },
  {  3757321980813615186u, 1461501637330902918u }, { 10384555214134712795u, 1169201309864722334u },
  {  5547241898389809503u, 1870722095783555735u }, {  4437793518711847602u, 1496577676626844588u },
  { 10928932444453298728u, 1197262141301475670u }, { 17486291911125277965u, 1915619426082361072u },
  {  6610335899416401726u, 1532495540865888858u }, { 12666966349016942027u, 1225996432692711086u },
  { 12888448528943286597u, 1961594292308337738u }, { 17689456452638449924u, 1569275433846670190u },
  { 14151565162110759939u, 1255420347077336152u }, {  7885109000409574610u, 2008672555323737844u },
  {  9997436015069570011u, 1606938044258990275u }, {  7997948812055656009u, 1285550435407192220u },
  { 12796718099289049614u, 2056880696651507552u }, {  2858676849947419045u, 1645504557321206042u },
  { 13354987924183666206u, 1316403645856964833u }, { 17678631863951955605u, 2106245833371143733u },
  {  3074859046935833515u, 1684996666696914987u }, { 13527933681774397782u, 1347997333357531989u },
  { 10576647446613305481u, 2156795733372051183u }, { 15840015586774465031u, 1725436586697640946u },
  {  8982663654677661702u, 1380349269358112757u }, { 18061610662226169046u, 2208558830972980411u },
  { 10759939715039024913u, 1766847064778384329u }, { 12297300586773130254u, 1413477651822707463u },
  { 15986332124095098083u, 2261564242916331941u }, {  9099716884534168143u, 1809251394333065553u },
  { 14658471137111155161u, 1447401115466452442u }, {  4348079280205103483u, 1157920892373161954u },
  { 14335624477811986218u, 1852673427797059126u }, {  7779150767507678651u, 1482138742237647301u },
  {  2533971799264232598u, 1185710993790117841u }, { 15122401323048503126u, 1897137590064188545u },
  { 12097921058438802501u, 1517710072051350836u }, {  5988988032009131678u, 1214168057641080669u },
  { 16961078480698431330u, 1942668892225729070u }, { 13568862784558745064u, 1554135113780583256u },
  {  7165741412905085728u, 1243308091024466605u }, { 11465186260648137165u, 1989292945639146568u },
  { 16550846638002330379u, 1591434356511317254u }, { 16930026125143774626u, 1273147485209053803u },
  {  4951948911778577463u, 2037035976334486086u }, {   272210314680951647u, 1629628781067588869u },
  {  3907117066486671641u, 1303703024854071095u }, {  6251387306378674625u, 2085924839766513752u },
  { 16069156289328670670u, 1668739871813211001u }, {  9165976216721026213u, 1334991897450568801u },
  {  7286864317269821294u, 2135987035920910082u }, { 16897537898041588005u, 1708789628736728065u },
  { 13518030318433270404u, 1367031702989382452u }, {  6871453250525591353u, 2187250724783011924u },
  {  9186511415162383406u, 1749800579826409539u }, { 11038557946871817048u, 1399840463861127631u },
  { 10282995085511086630u, 2239744742177804210u }, {  8226396068408869304u, 1791795793742243368u },
  { 13959814484210916090u, 1433436634993794694u }, { 11267656730511734774u, 2293498615990071511u },
  {  5324776569667477496u, 1834798892792057209u }, {  7949170070475892320u, 1467839114233645767u },
  { 17427382500606444826u, 1174271291386916613u }, {  5747719112518849781u, 1878834066219066582u },
  { 15666221734240810795u, 1503067252975253265u }, { 12532977387392648636u, 1202453802380202612u },
  {  5295368560860596524u, 1923926083808324180u }, {  4236294848688477220u, 1539140867046659344u },
  {  7078384693692692099u, 1231312693637327475u }, { 11325415509908307358u, 1970100309819723960u },
  {  9060332407926645887u, 1576080247855779168u }, { 14626963555825137356u, 1260864198284623334u },
  { 12335095245094488799u, 2017382717255397335u }, {  9868076196075591040u, 1613906173804317868u },
  { 15273158586344293478u, 1291124939043454294u }, { 13369007293925138595u, 2065799902469526871u },
  {  7005857020398200553u, 1652639921975621497u }, { 16672732060544291412u, 1322111937580497197u },
  { 11918976037903224966u, 2115379100128795516u }, {  5845832015580669650u, 1692303280103036413u },
  { 12055363241948356366u, 1353842624082429130u }, {   841837113407818570u, 2166148198531886609u },
  {  4362818505468165179u, 1732918558825509287u }, { 14558301248600263113u, 1386334847060407429u },
  { 12225235553534690011u, 2218135755296651887u }, {  2401490813343931363u, 1774508604237321510u },
  {  1921192650675145090u, 1419606883389857208u }, { 17831303500047873437u, 2271371013423771532u },
  {  6886345170554478103u, 1817096810739017226u }, {  1819727321701672159u, 1453677448591213781u },
  { 16213177116328979020u, 1162941958872971024u }, { 14873036941900635463u, 1860707134196753639u },
  { 15587778368262418694u, 1488565707357402911u }, {  8780873879868024632u, 1190852565885922329u },
  {  2981351763563108441u, 1905364105417475727u }, { 13453127855076217722u, 1524291284333980581u },
  {  7073153469319063855u, 1219433027467184465u }, { 11317045550910502167u, 1951092843947495144u },
  { 12742985255470312057u, 1560874275157996115u }, { 10194388204376249646u, 1248699420126396892u },
  {  1553625868034358140u, 1997919072202235028u }, {  8621598323911307159u, 1598335257761788022u },
  { 17965325103354776697u, 1278668206209430417u }, { 13987124906400001422u, 2045869129935088668u },
  {   121653480894270168u, 1636695303948070935u }, {    97322784715416134u, 1309356243158456748u },
  { 14913111714512307107u, 2094969989053530796u }, {  8241140556867935363u, 1675975991242824637u },
  { 17660958889720079260u, 1340780792994259709u }, { 17189487779326395846u, 2145249268790815535u },
  { 13751590223461116677u, 1716199415032652428u }, { 18379969808252713988u, 1372959532026121942u },
  { 14650556434236701088u, 2196735251241795108u }, {   652398703163629901u, 1757388200993436087u },
  { 11589965406756634890u, 1405910560794748869u }, {  7475898206584884855u, 2249456897271598191u },
  {  2291369750525997561u, 1799565517817278553u }, {  9211793429904618695u, 1439652414253822842u },
  { 18428218302589300235u, 2303443862806116547u }, {  7363877012587619542u, 1842755090244893238u },
  { 13269799239553916280u, 1474204072195914590u }, { 10615839391643133024u, 1179363257756731672u },
  {  2227947767661371545u, 1886981212410770676u }, { 16539753473096738529u, 1509584969928616540u },
  { 13231802778477390823u, 1207667975942893232u }, {  6413489186596184024u, 1932268761508629172u },
  { 16198837793502678189u, 1545815009206903337u }, {  5580372605318321905u, 1236652007365522670u },
  {  8928596168509315048u, 1978643211784836272u }, { 18210923379033183008u, 1582914569427869017u },
  {  7190041073742725760u, 1266331655542295214u }, {   436019273762630246u, 2026130648867672343u },
  {  7727513048493924843u, 1620904519094137874u }, {  9871359253537050198u, 1296723615275310299u },
  {  4726128361433549347u, 2074757784440496479u }, {  7470251503888749801u, 1659806227552397183u },
  { 13354898832594820487u, 1327844982041917746u }, { 13989140502667892133u, 2124551971267068394u },
  { 14880661216876224029u, 1699641577013654715u }, { 11904528973500979224u, 1359713261610923772u },
  {  4289851098633925465u, 2175541218577478036u }, { 18189276137874781665u, 1740432974861982428u },
  {  3483374466074094362u, 1392346379889585943u }, {  1884050330976640656u, 2227754207823337509u },
  {  5196589079523222848u, 1782203366258670007u }, { 15225317707844309248u, 1425762693006936005u },
  {  5913764258841343181u, 2281220308811097609u }, {  8420360221814984868u, 1824976247048878087u },
  { 17804334621677718864u, 1459980997639102469u }, { 17932816512084085415u, 1167984798111281975u },
  { 10245762345624985047u, 1868775676978051161u }, {  4507261061758077715u, 1495020541582440929u },
  {  7295157664148372495u, 1196016433265952743u }, {  7982903447895485668u, 1913626293225524389u },
  { 10075671573058298858u, 1530901034580419511u }, {  4371188443704728763u, 1224720827664335609u },
  { 14372599139411386667u, 1959553324262936974u }, { 15187428126271019657u, 1567642659410349579u },
  { 15839291315758726049u, 1254114127528279663u }, {  3206773216762499739u, 2006582604045247462u },
  { 13633465017635730761u, 1605266083236197969u }, { 14596120828850494932u, 1284212866588958375u },
  {  4907049252451240275u, 2054740586542333401u }, {   236290587219081897u, 1643792469233866721u },
  { 14946427728742906810u, 1315033975387093376u }, { 16535586736504830250u, 2104054360619349402u },
  {  5849771759720043554u, 1683243488495479522u }, { 15747863852001765813u, 1346594790796383617u },
  { 10439186904235184007u, 2154551665274213788u }, { 15730047152871967852u, 1723641332219371030u },
  { 12584037722297574282u, 1378913065775496824u }, {  9066413911450387881u, 2206260905240794919u },
  { 10942479943902220628u, 1765008724192635935u }, {  8753983955121776503u, 1412006979354108748u },
  { 10317025513452932081u, 2259211166966573997u }, {   874922781278525018u, 1807368933573259198u },
  {  8078635854506640661u, 1445895146858607358u }, { 13841606313089133175u, 1156716117486885886u },
  { 14767872471458792434u, 1850745787979017418u }, {   746251532941302978u, 1480596630383213935u },
  {   597001226353042382u, 1184477304306571148u }, { 15712597221132509104u, 1895163686890513836u },
  {  8880728962164096960u, 1516130949512411069u }, { 10793931984473187891u, 1212904759609928855u },
  { 17270291175157100626u, 1940647615375886168u }, {  2748186495899949531u, 1552518092300708935u },
  {  2198549196719959625u, 1242014473840567148u }, { 18275073973719576693u, 1987223158144907436u },
  { 10930710364233751031u, 1589778526515925949u }, { 12433917106128911148u, 1271822821212740759u },
  {  8826220925580526867u, 2034916513940385215u }, {  7060976740464421494u, 1627933211152308172u },
  { 16716827836597268165u, 1302346568921846537u }, { 11989529279587987770u, 2083754510274954460u },
  {  9591623423670390216u, 1667003608219963568u }, { 15051996368420132820u, 1333602886575970854u },
  { 13015147745246481542u, 2133764618521553367u }, {  3033420566713364587u, 1707011694817242694u },
  {  6116085268112601993u, 1365609355853794155u }, {  9785736428980163188u, 2184974969366070648u },
  { 15207286772667951197u, 1747979975492856518u }, {  1097782973908629988u, 1398383980394285215u },
  {  1756452758253807981u, 2237414368630856344u }, {  5094511021344956708u, 1789931494904685075u },
  {  4075608817075965366u, 1431945195923748060u }, {  6520974107321544586u, 2291112313477996896u },
  {  1527430471115325346u, 1832889850782397517u }, { 12289990821117991246u, 1466311880625918013u },
  { 17210690286378213644u, 1173049504500734410u }, {  9090360384495590213u, 1876879207201175057u },
  { 18340334751822203140u, 1501503365760940045u }, { 14672267801457762512u, 1201202692608752036u },
  { 16096930852848599373u, 1921924308174003258u }, {  1809498238053148529u, 1537539446539202607u },
  { 12515645034668249793u, 1230031557231362085u }, {  1578287981759648052u, 1968050491570179337u },
  { 12330676829633449412u, 1574440393256143469u }, { 13553890278448669853u, 1259552314604914775u },
  {  3239480371808320148u, 2015283703367863641u }, { 17348979556414297411u, 1612226962694290912u },
  {  6500486015647617283u, 1289781570155432730u }, { 10400777625036187652u, 2063650512248692368u },
  { 15699319729512770768u, 1650920409798953894u }, { 16248804598352126938u, 1320736327839163115u },
  {  7551343283653851484u, 2113178124542660985u }, {  6041074626923081187u, 1690542499634128788u },
  { 12211557331022285596u, 1352433999707303030u }, {  1091747655926105338u, 2163894399531684849u },
  {  4562746939482794594u, 1731115519625347879u }, {  7339546366328145998u, 1384892415700278303u },
  {  8053925371383123274u, 2215827865120445285u }, {  6443140297106498619u, 1772662292096356228u },
  { 12533209867169019542u, 1418129833677084982u }, {  5295740528502789974u, 2269007733883335972u },
  { 15304638867027962949u, 1815206187106668777u }, {  4865013464138549713u, 1452164949685335022u },
  { 14960057215536570740u, 1161731959748268017u }, {  9178696285890871890u, 1858771135597228828u },
  { 14721654658196518159u, 1487016908477783062u }, {  4398626097073393881u, 1189613526782226450u },
  {  7037801755317430209u, 1903381642851562320u }, {  5630241404253944167u, 1522705314281249856u },
  {   814844308661245011u, 1218164251424999885u }, {  1303750893857992017u, 1949062802279999816u },
  { 15800395974054034906u, 1559250241823999852u }, {  5261619149759407279u, 1247400193459199882u },
  { 12107939454356961969u, 1995840309534719811u }, {  5997002748743659252u, 1596672247627775849u },
  {  8486951013736837725u, 1277337798102220679u }, {  2511075177753209390u, 2043740476963553087u },
  { 13076906586428298482u, 1634992381570842469u }, { 14150874083884549109u, 1307993905256673975u },
  {  4194654460505726958u, 2092790248410678361u }, { 18113118827372222859u, 1674232198728542688u },
  {  3422448617672047318u, 1339385758982834151u }, { 16543964232501006678u, 2143017214372534641u },
  {  9545822571258895019u, 1714413771498027713u }, { 15015355686490936662u, 1371531017198422170u },
  {  5577825024675947042u, 2194449627517475473u }, { 11840957649224578280u, 1755559702013980378u },
  { 16851463748863483271u, 1404447761611184302u }, { 12204946739213931940u, 2247116418577894884u },
  { 13453306206113055875u, 1797693134862315907u }, {  3383947335406624054u, 1438154507889852726u },
  { 16482362180876329456u, 2301047212623764361u }, {  9496540929959153242u, 1840837770099011489u },
  { 11286581558709232917u, 1472670216079209191u }, {  5339916432225476010u, 1178136172863367353u },
  {  4854517476818851293u, 1885017876581387765u }, {  3883613981455081034u, 1508014301265110212u },
  { 14174937629389795797u, 1206411441012088169u }, { 11611853762797942306u, 1930258305619341071u },
  {  5600134195496443521u, 1544206644495472857u }, { 15548153800622885787u, 1235365315596378285u },
  {  6430302007287065643u, 1976584504954205257u }, { 16212288050055383484u, 1581267603963364205u },
  { 12969830440044306787u, 1265014083170691364u }, {  9683682259845159889u, 2024022533073106183u },
  { 15125643437359948558u, 1619218026458484946u }, {  8411165935146048523u, 1295374421166787957u },
  { 17147214310975587960u, 2072599073866860731u }, { 10028422634038560045u, 1658079259093488585u },
  {  8022738107230848036u, 1326463407274790868u }, {  9147032156827446534u, 2122341451639665389u },
  { 11006974540203867551u, 1697873161311732311u }, {  5116230817421183718u, 1358298529049385849u },
  { 15564666937357714594u, 2173277646479017358u }, {  1383687105660440706u, 1738622117183213887u },
  { 12174996128754083534u, 1390897693746571109u }, {  8411947361780802685u, 2225436309994513775u },
  {  6729557889424642148u, 1780349047995611020u }, {  5383646311539713719u, 1424279238396488816u },
  {  1235136468979721303u, 2278846781434382106u }, { 15745504434151418335u, 1823077425147505684u },
  { 16285752362063044992u, 1458461940118004547u }, {  5649904260166615347u, 1166769552094403638u },
  {  5350498001524674232u, 1866831283351045821u }, {   591049586477829062u, 1493465026680836657u },
  { 11540886113407994219u, 1194772021344669325u }, {    18673707743239135u, 1911635234151470921u },
  { 14772334225162232601u, 1529308187321176736u }, {  8128518565387875758u, 1223446549856941389u },
  {  1937583260394870242u, 1957514479771106223u }, {  8928764237799716840u, 1566011583816884978u },
  { 14521709019723594119u, 1252809267053507982u }, {  8477339172590109297u, 2004494827285612772u },
  { 17849917782297818407u, 1603595861828490217u }, {  6901236596354434079u, 1282876689462792174u },
  { 18420676183650915173u, 2052602703140467478u }, {  3668494502695001169u, 1642082162512373983u },
  { 10313493231639821582u, 1313665730009899186u }, {  9122891541139893884u, 2101865168015838698u },
  { 14677010862395735754u, 1681492134412670958u }, {   673562245690857633u, 1345193707530136767u }
};

NANOSTL_GLOBAL_QUAL NANOSTL_CONSTANT_QUAL
static const uint64_t DOUBLE_POW5_SPLIT[RYU_DOUBLE_POW5_TABLE_SIZE][2] = {
  {                    0u, 1152921504606846976u }, {                    0u, 1441151880758558720u },
  {                    0u, 1801439850948198400u }, {                    0u, 2251799813685248000u },
  {                    0u, 1407374883553280000u }, {                    0u, 1759218604441600000u },
  {                    0u, 2199023255552000000u }, {                    0u, 1374389534720000000u },
  {                    0u, 1717986918400000000u }, {                    0u, 2147483648000000000u },
  {                    0u, 1342177280000000000u }, {                    0u, 1677721600000000000u },
  {                    0u, 2097152000000000000u }, {                    0u, 1310720000000000000u },
  {                    0u, 1638400000000000000u }, {                    0u, 2048000000000000000u },
  {                    0u, 1280000000000000000u }, {                    0u, 1600000000000000000u },
  {                    0u, 2000000000000000000u }, {                    0u, 1250000000000000000u },
  {                    0u, 1562500000000000000u }, {                    0u, 1953125000000000000u },
  {                    0u, 1220703125000000000u }, {                    0u, 1525878906250000000u },
  {                    0u, 1907348632812500000u }, {                    0u, 1192092895507812500u },
  {                    0u, 1490116119384765625u }, {  4611686018427387904u, 1862645149230957031u },
  {  9799832789158199296u, 1164153218269348144u }, { 12249790986447749120u, 1455191522836685180u },
  { 15312238733059686400u, 1818989403545856475u }, { 14528612397897220096u, 2273736754432320594u },
  { 13692068767113150464u, 1421085471520200371u }, { 12503399940464050176u, 1776356839400250464u },
  { 15629249925580062720u, 2220446049250313080u }, {  9768281203487539200u, 1387778780781445675u },
  {  7598665485932036096u, 1734723475976807094u }, {   274959820560269312u, 2168404344971008868u },
  {  9395221924704944128u, 1355252715606880542u }, {  2520655369026404352u, 1694065894508600678u },
  { 12374191248137781248u, 2117582368135750847u }, { 14651398557727195136u, 1323488980084844279u },
  { 13702562178731606016u, 1654361225106055349u }, {  3293144668132343808u, 2067951531382569187u },
  { 18199116482078572544u, 1292469707114105741u }, {  8913837547316051968u, 1615587133892632177u },
  { 15753982952572452864u, 2019483917365790221u }, { 12152082354571476992u, 1262177448353618888u },
  { 15190102943214346240u, 1577721810442023610u }, {  9764256642163156992u, 1972152263052529513u },
  { 17631875447420442880u, 1232595164407830945u }, {  8204786253993389888u, 1540743955509788682u },
  {  1032610780636961552u, 1925929944387235853u }, {  2951224747111794922u, 1203706215242022408u },
  {  3689030933889743652u, 1504632769052528010u }, { 13834660704216955373u, 1880790961315660012u },
  { 17870034976990372916u, 1175494350822287507u }, { 17725857702810578241u, 1469367938527859384u },
  {  3710578054803671186u, 1836709923159824231u }, {    26536550077201078u, 2295887403949780289u },
  { 11545800389866720434u, 1434929627468612680u }, { 14432250487333400542u, 1793662034335765850u },
  {  8816941072311974870u, 2242077542919707313u }, { 17039803216263454053u, 1401298464324817070u },
  { 12076381983474541759u, 1751623080406021338u }, {  5872105442488401391u, 2189528850507526673u },
  { 15199280947623720629u, 1368455531567204170u }, {  9775729147674874978u, 1710569414459005213u },
  { 16831347453020981627u, 2138211768073756516u }, {  1296220121283337709u, 1336382355046097823u },
  { 15455333206886335848u, 1670477943807622278u }, { 10095794471753144002u, 2088097429759527848u },
  {  6309871544845715001u, 1305060893599704905u }, { 12499025449484531656u, 1631326116999631131u },
  { 11012095793428276666u, 2039157646249538914u }, { 11494245889320060820u, 1274473528905961821u },
  {   532749306367912313u, 1593091911132452277u }, {  5277622651387278295u, 1991364888915565346u },
  {  7910200175544436838u, 1244603055572228341u }, { 14499436237857933952u, 1555753819465285426u },
  {  8900923260467641632u, 1944692274331606783u }, { 12480606065433357876u, 1215432671457254239u },
  { 10989071563364309441u, 1519290839321567799u }, {  9124653435777998898u, 1899113549151959749u },
  {  8008751406574943263u, 1186945968219974843u }, {  5399253239791291175u, 1483682460274968554u },
  { 15972438586593889776u, 1854603075343710692u }, {   759402079766405302u, 1159126922089819183u },
  { 14784310654990170340u, 1448908652612273978u }, {  9257016281882937117u, 1811135815765342473u },
  { 16182956370781059300u, 2263919769706678091u }, {  7808504722524468110u, 1414949856066673807u },
  {  5148944884728197234u, 1768687320083342259u }, {  1824495087482858639u, 2210859150104177824u },
  {  1140309429676786649u, 1381786968815111140u }, {  1425386787095983311u, 1727233711018888925u },
  {  6393419502297367043u, 2159042138773611156u }, { 13219259225790630210u, 1349401336733506972u },
  { 16524074032238287762u, 1686751670916883715u }, { 16043406521870471799u, 2108439588646104644u },
  {   803757039314269066u, 1317774742903815403u }, { 14839754354425000045u, 1647218428629769253u },
  {  4714634887749086344u, 2059023035787211567u }, {  9864175832484260821u, 1286889397367007229u },
  { 16941905809032713930u, 1608611746708759036u }, {  2730638187581340797u, 2010764683385948796u },
  { 10930020904093113806u, 1256727927116217997u }, { 18274212148543780162u, 1570909908895272496u },
  {  4396021111970173586u, 1963637386119090621u }, {  5053356204195052443u, 1227273366324431638u },
  { 15540067292098591362u, 1534091707905539547u }, { 14813398096695851299u, 1917614634881924434u },
  { 13870059828862294966u, 1198509146801202771u }, { 12725888767650480803u, 1498136433501503464u },
  { 15907360959563101004u, 1872670541876879330u }, { 14553786618154326031u, 1170419088673049581u },
  {  4357175217410743827u, 1463023860841311977u }, { 10058155040190817688u, 1828779826051639971u },
  {  7961007781811134206u, 2285974782564549964u }, { 14199001900486734687u, 1428734239102843727u },
  { 13137066357181030455u, 1785917798878554659u }, { 11809646928048900164u, 2232397248598193324u },
  { 16604401366885338411u, 1395248280373870827u }, { 16143815690179285109u, 1744060350467338534u },
  { 10956397575869330579u, 2180075438084173168u }, {  6847748484918331612u, 1362547148802608230u },
  { 17783057643002690323u, 1703183936003260287u }, { 17617136035325974999u, 2128979920004075359u },
  { 17928239049719816230u, 1330612450002547099u }, { 17798612793722382384u, 1663265562503183874u },
  { 13024893955298202172u, 2079081953128979843u }, {  5834715712847682405u, 1299426220705612402u },
  { 16516766677914378815u, 1624282775882015502u }, { 11422586310538197711u, 2030353469852519378u },
  { 11750802462513761473u, 1268970918657824611u }, { 10076817059714813937u, 1586213648322280764u },
  { 12596021324643517422u, 1982767060402850955u }, {  5566670318688504437u, 1239229412751781847u },
  {  2346651879933242642u, 1549036765939727309u }, {  7545000868343941206u, 1936295957424659136u },
  {  4715625542714963254u, 1210184973390411960u }, {  5894531928393704067u, 1512731216738014950u },
  { 16591536947346905892u, 1890914020922518687u }, { 17287239619732898039u, 1181821263076574179u },
  { 16997363506238734644u, 1477276578845717724u }, {  2799960309088866689u, 1846595723557147156u },
  { 10973347230035317489u, 1154122327223216972u }, { 13716684037544146861u, 1442652909029021215u },
  { 12534169028502795672u, 1803316136286276519u }, { 11056025267201106687u, 2254145170357845649u },
  { 18439230838069161439u, 1408840731473653530u }, { 13825666510731675991u, 1761050914342066913u },
  {  3447025083132431277u, 2201313642927583642u }, {  6766076695385157452u, 1375821026829739776u },
  {  8457595869231446815u, 1719776283537174720u }, { 10571994836539308519u, 2149720354421468400u },
  {  6607496772837067824u, 1343575221513417750u }, { 17482743002901110588u, 1679469026891772187u },
  { 17241742735199000331u, 2099336283614715234u }, { 15387775227926763111u, 1312085177259197021u },
  {  5399660979626290177u, 1640106471573996277u }, { 11361262242960250625u, 2050133089467495346u },
  { 11712474920277544544u, 1281333180917184591u }, { 10028907631919542777u, 1601666476146480739u },
  {  7924448521472040567u, 2002083095183100924u }, { 14176152362774801162u, 1251301934489438077u },
  {  3885132398186337741u, 1564127418111797597u }, {  9468101516160310080u, 1955159272639746996u },
  { 15140935484454969608u, 1221974545399841872u }, {   479425281859160394u, 1527468181749802341u },
  {  5210967620751338397u, 1909335227187252926u }, { 17091912818251750210u, 1193334516992033078u },
  { 12141518985959911954u, 1491668146240041348u }, { 15176898732449889943u, 1864585182800051685u },
  { 11791404716994875166u, 1165365739250032303u }, { 10127569877816206054u, 1456707174062540379u },
  {  8047776328842869663u, 1820883967578175474u }, {   836348374198811271u, 2276104959472719343u },
  {  7440246761515338900u, 1422565599670449589u }, { 13911994470321561530u, 1778206999588061986u },
  {  8166621051047176104u, 2222758749485077483u }, {  2798295147690791113u, 1389224218428173427u },
  { 17332926989895652603u, 1736530273035216783u }, { 17054472718942177850u, 2170662841294020979u },
  {  8353202440125167204u, 1356664275808763112u }, { 10441503050156459005u, 1695830344760953890u },
  {  3828506775840797949u, 2119787930951192363u }, {    86973725686804766u, 1324867456844495227u },
  { 13943775212390669669u, 1656084321055619033u }, {  3594660960206173375u, 2070105401319523792u },
  {  2246663100128858359u, 1293815875824702370u }, { 12031700912015848757u, 1617269844780877962u },
  {  5816254103165035138u, 2021587305976097453u }, {  5941001823691840913u, 1263492066235060908u },
  {  7426252279614801142u, 1579365082793826135u }, {  4671129331091113523u, 1974206353492282669u },
  {  5225298841145639904u, 1233878970932676668u }, {  6531623551432049880u, 1542348713665845835u },
  {  3552843420862674446u, 1927935892082307294u }, { 16055585193321335241u, 1204959932551442058u },
  { 10846109454796893243u, 1506199915689302573u }, { 18169322836923504458u, 1882749894611628216u },
  { 11355826773077190286u, 1176718684132267635u }, {  9583097447919099954u, 1470898355165334544u },
  { 11978871809898874942u, 1838622943956668180u }, { 14973589762373593678u, 2298278679945835225u },
  {  2440964573842414192u, 1436424174966147016u }, {  3051205717303017741u, 1795530218707683770u },
  { 13037379183483547984u, 2244412773384604712u }, {  8148361989677217490u, 1402757983365377945u },
  { 14797138505523909766u, 1753447479206722431u }, { 13884737113477499304u, 2191809349008403039u },
  { 15595489723564518921u, 1369880843130251899u }, { 14882676136028260747u, 1712351053912814874u },
  {  9379973133180550126u, 2140438817391018593u }, { 17391698254306313589u, 1337774260869386620u },
  {  3292878744173340370u, 1672217826086733276u }, {  4116098430216675462u, 2090272282608416595u },
  {   266718509671728212u, 1306420176630260372u }, {   333398137089660265u, 1633025220787825465u },
  {  5028433689789463235u, 2041281525984781831u }, { 10060300083759496378u, 1275800953740488644u },
  { 12575375104699370472u, 1594751192175610805u }, {  1884160825592049379u, 1993438990219513507u },
  { 17318501580490888525u, 1245899368887195941u }, {  7813068920331446945u, 1557374211108994927u },
  {  5154650131986920777u, 1946717763886243659u }, {   915813323278131534u, 1216698602428902287u },
  { 14979824709379828129u, 1520873253036127858u }, {  9501408849870009354u, 1901091566295159823u },
  { 12855909558809837702u, 1188182228934474889u }, {  2234828893230133415u, 1485227786168093612u },
  {  2793536116537666769u, 1856534732710117015u }, {  8663489100477123587u, 1160334207943823134u },
  {  1605989338741628675u, 1450417759929778918u }, { 11230858710281811652u, 1813022199912223647u },
  {  9426887369424876662u, 2266277749890279559u }, { 12809333633531629769u, 1416423593681424724u },
  { 16011667041914537212u, 1770529492101780905u }, {  6179525747111007803u, 2213161865127226132u },
  { 13085575628799155685u, 1383226165704516332u }, { 16356969535998944606u, 1729032707130645415u },
  { 15834525901571292854u, 2161290883913306769u }, {  2979049660840976177u, 1350806802445816731u },
  { 17558870131333383934u, 1688508503057270913u }, {  8113529608884566205u, 2110635628821588642u },
  {  9682642023980241782u, 1319147268013492901u }, { 16714988548402690132u, 1648934085016866126u },
  { 11670363648648586857u, 2061167606271082658u }, { 11905663298832754689u, 1288229753919426661u },
  {  1047021068258779650u, 1610287192399283327u }, { 15143834390605638274u, 2012858990499104158u },
  {  4853210475701136017u, 1258036869061940099u }, {  1454827076199032118u, 1572546086327425124u },
  {  1818533845248790147u, 1965682607909281405u }, {  3442426662494187794u, 1228551629943300878u },
  { 13526405364972510550u, 1535689537429126097u }, {  3072948650933474476u, 1919611921786407622u },
  { 15755650962115585259u, 1199757451116504763u }, { 15082877684217093670u, 1499696813895630954u },
  {  9630225068416591280u, 1874621017369538693u }, {  8324733676974063502u, 1171638135855961683u },
  {  5794231077790191473u, 1464547669819952104u }, {  7242788847237739342u, 1830684587274940130u },
  { 18276858095901949986u, 2288355734093675162u }, { 16034722328366106645u, 1430222333808546976u },
  {  1596658836748081690u, 1787777917260683721u }, {  6607509564362490017u, 2234722396575854651u },
  {  1823850468512862308u, 1396701497859909157u }, {  6891499104068465790u, 1745876872324886446u },
  { 17837745916940358045u, 2182346090406108057u }, {  4231062170446641922u, 1363966306503817536u },
  {  5288827713058302403u, 1704957883129771920u }, {  6611034641322878003u, 2131197353912214900u },
  { 13355268687681574560u, 1331998346195134312u }, { 16694085859601968200u, 1664997932743917890u },
  { 11644235287647684442u, 2081247415929897363u }, {  4971804045566108824u, 1300779634956185852u },
  {  6214755056957636030u, 1625974543695232315u }, {  3156757802769657134u, 2032468179619040394u },
  {  6584659645158423613u, 1270292612261900246u }, { 17454196593302805324u, 1587865765327375307u },
  { 17206059723201118751u, 1984832206659219134u }, {  6142101308573311315u, 1240520129162011959u },
  {  3065940617289251240u, 1550650161452514949u }, {  8444111790038951954u, 1938312701815643686u },
  {   665883850346957067u, 1211445438634777304u }, {   832354812933696334u, 1514306798293471630u },
  { 10263815553021896226u, 1892883497866839537u }, { 17944099766707154901u, 1183052186166774710u },
  { 13206752671529167818u, 1478815232708468388u }, { 16508440839411459773u, 1848519040885585485u },
  { 12623618533845856310u, 1155324400553490928u }, { 15779523167307320387u, 1444155500691863660u },
  {  1277659885424598868u, 1805194375864829576u }, {  1597074856780748586u, 2256492969831036970u },
  {  5609857803915355770u, 1410308106144398106u }, { 16235694291748970521u, 1762885132680497632u },
  {  1847873790976661535u, 2203606415850622041u }, { 12684136165428883219u, 1377254009906638775u },
  { 11243484188358716120u, 1721567512383298469u }, {   219297180166231438u, 2151959390479123087u },
  {  7054589765244976505u, 1344974619049451929u }, { 13429923224983608535u, 1681218273811814911u },
  { 12175718012802122765u, 2101522842264768639u }, { 14527352785642408584u, 1313451776415480399u },
  { 13547504963625622826u, 1641814720519350499u }, { 12322695186104640628u, 2052268400649188124u },
  { 16925056528170176201u, 1282667750405742577u }, {  7321262604930556539u, 1603334688007178222u },
  { 18374950293017971482u, 2004168360008972777u }, {  4566814905495150320u, 1252605225005607986u },
  { 14931890668723713708u, 1565756531257009982u }, {  9441491299049866327u, 1957195664071262478u },
  {  1289246043478778550u, 1223247290044539049u }, {  6223243572775861092u, 1529059112555673811u },
  {  3167368447542438461u, 1911323890694592264u }, {  1979605279714024038u, 1194577431684120165u },
  {  7086192618069917952u, 1493221789605150206u }, { 18081112809442173248u, 1866527237006437757u },
  { 13606538515115052232u, 1166579523129023598u }, {  7784801107039039482u, 1458224403911279498u },
  {   507629346944023544u, 1822780504889099373u }, {  5246222702107417334u, 2278475631111374216u },
  {  3278889188817135834u, 1424047269444608885u }, {  8710297504448807696u, 1780059086805761106u }
};

#endif // RYU_D2S_FULL_TABLE_H
#endif
#define RYU_FLOAT_POW5_INV_BITCOUNT (RYU_DOUBLE_POW5_INV_BITCOUNT - 64)
#define RYU_FLOAT_POW5_BITCOUNT (RYU_DOUBLE_POW5_BITCOUNT - 64)

// A floating decimal representing m * 10^e.
typedef struct floating_decimal_32 {
  uint32_t mantissa;
  // Decimal exponent's range is -45 to 38
  // inclusive, and can fit in a short if needed.
  int32_t exponent;
} floating_decimal_32;

// Returns e == 0 ? 1 : [log_2(5^e)]; requires 0 <= e <= 3528.
NANOSTL_HOST_AND_DEVICE_QUAL
static inline int32_t log2pow5(const int32_t e) {
  // This approximation works up to the point that the multiplication overflows at e = 3529.
  // If the multiplication were done in 64 bits, it would fail at 5^4004 which is just greater
  // than 2^9297.
  assert(e >= 0);
  assert(e <= 3528);
  return (int32_t) ((((uint32_t) e) * 1217359) >> 19);
}

// Returns e == 0 ? 1 : ceil(log_2(5^e)); requires 0 <= e <= 3528.
NANOSTL_HOST_AND_DEVICE_QUAL
static inline int32_t pow5bits(const int32_t e) {
  // This approximation works up to the point that the multiplication overflows at e = 3529.
  // If the multiplication were done in 64 bits, it would fail at 5^4004 which is just greater
  // than 2^9297.
  assert(e >= 0);
  assert(e <= 3528);
  return (int32_t) (((((uint32_t) e) * 1217359) >> 19) + 1);
}

// Returns e == 0 ? 1 : ceil(log_2(5^e)); requires 0 <= e <= 3528.
NANOSTL_HOST_AND_DEVICE_QUAL
static inline int32_t ceil_log2pow5(const int32_t e) {
  return log2pow5(e) + 1;
}

// Returns floor(log_10(2^e)); requires 0 <= e <= 1650.
NANOSTL_HOST_AND_DEVICE_QUAL
static inline uint32_t log10Pow2(const int32_t e) {
  // The first value this approximation fails for is 2^1651 which is just greater than 10^297.
  assert(e >= 0);
  assert(e <= 1650);
  return (((uint32_t) e) * 78913) >> 18;
}

// Returns floor(log_10(5^e)); requires 0 <= e <= 2620.
NANOSTL_HOST_AND_DEVICE_QUAL
static inline uint32_t log10Pow5(const int32_t e) {
  // The first value this approximation fails for is 5^2621 which is just greater than 10^1832.
  assert(e >= 0);
  assert(e <= 2620);
  return (((uint32_t) e) * 732923) >> 20;
}

NANOSTL_HOST_AND_DEVICE_QUAL
static inline uint32_t pow5factor_32(uint32_t value) {
  uint32_t count = 0;
  for (;;) {
    assert(value != 0);
    const uint32_t q = value / 5;
    const uint32_t r = value % 5;
    if (r != 0) {
      break;
    }
    value = q;
    ++count;
  }
  return count;
}

// Returns true if value is divisible by 5^p.
NANOSTL_HOST_AND_DEVICE_QUAL
static inline bool multipleOfPowerOf5_32(const uint32_t value, const uint32_t p) {
  return pow5factor_32(value) >= p;
}

// Returns true if value is divisible by 2^p.
NANOSTL_HOST_AND_DEVICE_QUAL
static inline bool multipleOfPowerOf2_32(const uint32_t value, const uint32_t p) {
  // __builtin_ctz doesn't appear to be faster here.
  return (value & ((1u << p) - 1)) == 0;
}

// It seems to be slightly faster to avoid uint128_t here, although the
// generated code for uint128_t looks slightly nicer.
NANOSTL_HOST_AND_DEVICE_QUAL
static inline uint32_t mulShift32(const uint32_t m, const uint64_t factor, const int32_t shift) {
  assert(shift > 32);

  // The casts here help MSVC to avoid calls to the __allmul library
  // function.
  const uint32_t factorLo = (uint32_t)(factor);
  const uint32_t factorHi = (uint32_t)(factor >> 32);
  const uint64_t bits0 = (uint64_t)m * factorLo;
  const uint64_t bits1 = (uint64_t)m * factorHi;

#if defined(RYU_32_BIT_PLATFORM)
  // On 32-bit platforms we can avoid a 64-bit shift-right since we only
  // need the upper 32 bits of the result and the shift value is > 32.
  const uint32_t bits0Hi = (uint32_t)(bits0 >> 32);
  uint32_t bits1Lo = (uint32_t)(bits1);
  uint32_t bits1Hi = (uint32_t)(bits1 >> 32);
  bits1Lo += bits0Hi;
  bits1Hi += (bits1Lo < bits0Hi);
  if (shift >= 64) {
    // s2f can call this with a shift value >= 64, which we have to handle.
    // This could now be slower than the !defined(RYU_32_BIT_PLATFORM) case.
    return (uint32_t)(bits1Hi >> (shift - 64));
  } else {
    const int32_t s = shift - 32;
    return (bits1Hi << (32 - s)) | (bits1Lo >> s);
  }
#else // RYU_32_BIT_PLATFORM
  const uint64_t sum = (bits0 >> 32) + bits1;
  const uint64_t shiftedSum = sum >> (shift - 32);
  assert(shiftedSum <= 4294967295); // UINT32_MAX
  return (uint32_t) shiftedSum;
#endif // RYU_32_BIT_PLATFORM
}

NANOSTL_HOST_AND_DEVICE_QUAL
static inline uint32_t mulPow5InvDivPow2(const uint32_t m, const uint32_t q, const int32_t j) {
#if defined(RYU_FLOAT_FULL_TABLE)
  return mulShift32(m, FLOAT_POW5_INV_SPLIT[q], j);
#elif defined(RYU_OPTIMIZE_SIZE)
  // The inverse multipliers are defined as [2^x / 5^y] + 1; the upper 64 bits from the double lookup
  // table are the correct bits for [2^x / 5^y], so we have to add 1 here. Note that we rely on the
  // fact that the added 1 that's already stored in the table never overflows into the upper 64 bits.
  uint64_t pow5[2];
  double_computeInvPow5(q, pow5);
  return mulShift32(m, pow5[1] + 1, j);
#else
  return mulShift32(m, DOUBLE_POW5_INV_SPLIT[q][1] + 1, j);
#endif
}

NANOSTL_HOST_AND_DEVICE_QUAL
static inline uint32_t mulPow5divPow2(const uint32_t m, const uint32_t i, const int32_t j) {
#if defined(RYU_FLOAT_FULL_TABLE)
  return mulShift32(m, FLOAT_POW5_SPLIT[i], j);
#elif defined(RYU_OPTIMIZE_SIZE)
  uint64_t pow5[2];
  double_computePow5(i, pow5);
  return mulShift32(m, pow5[1], j);
#else
  return mulShift32(m, DOUBLE_POW5_SPLIT[i][1], j);
#endif
}

NANOSTL_HOST_AND_DEVICE_QUAL
static inline floating_decimal_32 f2d(const uint32_t ieeeMantissa, const uint32_t ieeeExponent) {
  int32_t e2;
  uint32_t m2;
  if (ieeeExponent == 0) {
    // We subtract 2 so that the bounds computation has 2 additional bits.
    e2 = 1 - RYU_FLOAT_BIAS - RYU_FLOAT_MANTISSA_BITS - 2;
    m2 = ieeeMantissa;
  } else {
    e2 = (int32_t) ieeeExponent - RYU_FLOAT_BIAS - RYU_FLOAT_MANTISSA_BITS - 2;
    m2 = (1u << RYU_FLOAT_MANTISSA_BITS) | ieeeMantissa;
  }
  const bool even = (m2 & 1) == 0;
  const bool acceptBounds = even;

#ifdef RYU_DEBUG
  printf("-> %u * 2^%d\n", m2, e2 + 2);
#endif

  // Step 2: Determine the interval of valid decimal representations.
  const uint32_t mv = 4 * m2;
  const uint32_t mp = 4 * m2 + 2;
  // Implicit bool -> int conversion. True is 1, false is 0.
  const uint32_t mmShift = ieeeMantissa != 0 || ieeeExponent <= 1;
  const uint32_t mm = 4 * m2 - 1 - mmShift;

  // Step 3: Convert to a decimal power base using 64-bit arithmetic.
  uint32_t vr, vp, vm;
  int32_t e10;
  bool vmIsTrailingZeros = false;
  bool vrIsTrailingZeros = false;
  uint8_t lastRemovedDigit = 0;
  if (e2 >= 0) {
    const uint32_t q = log10Pow2(e2);
    e10 = (int32_t) q;
    const int32_t k = RYU_FLOAT_POW5_INV_BITCOUNT + pow5bits((int32_t) q) - 1;
    const int32_t i = -e2 + (int32_t) q + k;
    vr = mulPow5InvDivPow2(mv, q, i);
    vp = mulPow5InvDivPow2(mp, q, i);
    vm = mulPow5InvDivPow2(mm, q, i);
#ifdef RYU_DEBUG
    printf("%u * 2^%d / 10^%u\n", mv, e2, q);
    printf("V+=%u\nV =%u\nV-=%u\n", vp, vr, vm);
#endif
    if (q != 0 && (vp - 1) / 10 <= vm / 10) {
      // We need to know one removed digit even if we are not going to loop below. We could use
      // q = X - 1 above, except that would require 33 bits for the result, and we've found that
      // 32-bit arithmetic is faster even on 64-bit machines.
      const int32_t l = RYU_FLOAT_POW5_INV_BITCOUNT + pow5bits((int32_t) (q - 1)) - 1;
      lastRemovedDigit = (uint8_t) (mulPow5InvDivPow2(mv, q - 1, -e2 + (int32_t) q - 1 + l) % 10);
    }
    if (q <= 9) {
      // The largest power of 5 that fits in 24 bits is 5^10, but q <= 9 seems to be safe as well.
      // Only one of mp, mv, and mm can be a multiple of 5, if any.
      if (mv % 5 == 0) {
        vrIsTrailingZeros = multipleOfPowerOf5_32(mv, q);
      } else if (acceptBounds) {
        vmIsTrailingZeros = multipleOfPowerOf5_32(mm, q);
      } else {
        vp -= multipleOfPowerOf5_32(mp, q);
      }
    }
  } else {
    const uint32_t q = log10Pow5(-e2);
    e10 = (int32_t) q + e2;
    const int32_t i = -e2 - (int32_t) q;
    const int32_t k = pow5bits(i) - RYU_FLOAT_POW5_BITCOUNT;
    int32_t j = (int32_t) q - k;
    vr = mulPow5divPow2(mv, (uint32_t) i, j);
    vp = mulPow5divPow2(mp, (uint32_t) i, j);
    vm = mulPow5divPow2(mm, (uint32_t) i, j);
#ifdef RYU_DEBUG
    printf("%u * 5^%d / 10^%u\n", mv, -e2, q);
    printf("%u %d %d %d\n", q, i, k, j);
    printf("V+=%u\nV =%u\nV-=%u\n", vp, vr, vm);
#endif
    if (q != 0 && (vp - 1) / 10 <= vm / 10) {
      j = (int32_t) q - 1 - (pow5bits(i + 1) - RYU_FLOAT_POW5_BITCOUNT);
      lastRemovedDigit = (uint8_t) (mulPow5divPow2(mv, (uint32_t) (i + 1), j) % 10);
    }
    if (q <= 1) {
      // {vr,vp,vm} is trailing zeros if {mv,mp,mm} has at least q trailing 0 bits.
      // mv = 4 * m2, so it always has at least two trailing 0 bits.
      vrIsTrailingZeros = true;
      if (acceptBounds) {
        // mm = mv - 1 - mmShift, so it has 1 trailing 0 bit iff mmShift == 1.
        vmIsTrailingZeros = mmShift == 1;
      } else {
        // mp = mv + 2, so it always has at least one trailing 0 bit.
        --vp;
      }
    } else if (q < 31) { // TODO(ulfjack): Use a tighter bound here.
      vrIsTrailingZeros = multipleOfPowerOf2_32(mv, q - 1);
#ifdef RYU_DEBUG
      printf("vr is trailing zeros=%s\n", vrIsTrailingZeros ? "true" : "false");
#endif
    }
  }

#ifdef RYU_DEBUG
  printf("e10=%d\n", e10);
  printf("V+=%u\nV =%u\nV-=%u\n", vp, vr, vm);
  printf("vm is trailing zeros=%s\n", vmIsTrailingZeros ? "true" : "false");
  printf("vr is trailing zeros=%s\n", vrIsTrailingZeros ? "true" : "false");
#endif

  // Step 4: Find the shortest decimal representation in the interval of valid representations.
  int32_t removed = 0;
  uint32_t output;
  if (vmIsTrailingZeros || vrIsTrailingZeros) {
    // General case, which happens rarely (~4.0%).
    while (vp / 10 > vm / 10) {
#ifdef __clang__ // https://bugs.llvm.org/show_bug.cgi?id=23106
      // The compiler does not realize that vm % 10 can be computed from vm / 10
      // as vm - (vm / 10) * 10.
      vmIsTrailingZeros &= vm - (vm / 10) * 10 == 0;
#else
      vmIsTrailingZeros &= vm % 10 == 0;
#endif
      vrIsTrailingZeros &= lastRemovedDigit == 0;
      lastRemovedDigit = (uint8_t) (vr % 10);
      vr /= 10;
      vp /= 10;
      vm /= 10;
      ++removed;
    }
#ifdef RYU_DEBUG
    printf("V+=%u\nV =%u\nV-=%u\n", vp, vr, vm);
    printf("d-10=%s\n", vmIsTrailingZeros ? "true" : "false");
#endif
    if (vmIsTrailingZeros) {
      while (vm % 10 == 0) {
        vrIsTrailingZeros &= lastRemovedDigit == 0;
        lastRemovedDigit = (uint8_t) (vr % 10);
        vr /= 10;
        vp /= 10;
        vm /= 10;
        ++removed;
      }
    }
#ifdef RYU_DEBUG
    printf("%u %d\n", vr, lastRemovedDigit);
    printf("vr is trailing zeros=%s\n", vrIsTrailingZeros ? "true" : "false");
#endif
    if (vrIsTrailingZeros && lastRemovedDigit == 5 && vr % 2 == 0) {
      // Round even if the exact number is .....50..0.
      lastRemovedDigit = 4;
    }
    // We need to take vr + 1 if vr is outside bounds or we need to round up.
    output = vr + ((vr == vm && (!acceptBounds || !vmIsTrailingZeros)) || lastRemovedDigit >= 5);
  } else {
    // Specialized for the common case (~96.0%). Percentages below are relative to this.
    // Loop iterations below (approximately):
    // 0: 13.6%, 1: 70.7%, 2: 14.1%, 3: 1.39%, 4: 0.14%, 5+: 0.01%
    while (vp / 10 > vm / 10) {
      lastRemovedDigit = (uint8_t) (vr % 10);
      vr /= 10;
      vp /= 10;
      vm /= 10;
      ++removed;
    }
#ifdef RYU_DEBUG
    printf("%u %d\n", vr, lastRemovedDigit);
    printf("vr is trailing zeros=%s\n", vrIsTrailingZeros ? "true" : "false");
#endif
    // We need to take vr + 1 if vr is outside bounds or we need to round up.
    output = vr + (vr == vm || lastRemovedDigit >= 5);
  }
  const int32_t exp = e10 + removed;

#ifdef RYU_DEBUG
  printf("V+=%u\nV =%u\nV-=%u\n", vp, vr, vm);
  printf("O=%u\n", output);
  printf("EXP=%d\n", exp);
#endif

  floating_decimal_32 fd;
  fd.exponent = exp;
  fd.mantissa = output;
  return fd;
}

// Returns the number of decimal digits in v, which must not contain more than 9 digits.
NANOSTL_HOST_AND_DEVICE_QUAL
static inline uint32_t decimalLength9(const uint32_t v) {
  // Function precondition: v is not a 10-digit number.
  // (f2s: 9 digits are sufficient for round-tripping.)
  // (d2fixed: We print 9-digit blocks.)
  assert(v < 1000000000);
  if (v >= 100000000) { return 9; }
  if (v >= 10000000) { return 8; }
  if (v >= 1000000) { return 7; }
  if (v >= 100000) { return 6; }
  if (v >= 10000) { return 5; }
  if (v >= 1000) { return 4; }
  if (v >= 100) { return 3; }
  if (v >= 10) { return 2; }
  return 1;
}

NANOSTL_HOST_AND_DEVICE_QUAL
static inline uint32_t decimalLength17(const uint64_t v) {
  // This is slightly faster than a loop.
  // The average output length is 16.38 digits, so we check high-to-low.
  // Function precondition: v is not an 18, 19, or 20-digit number.
  // (17 digits are sufficient for round-tripping.)
  assert(v < 100000000000000000L);
  if (v >= 10000000000000000L) { return 17; }
  if (v >= 1000000000000000L) { return 16; }
  if (v >= 100000000000000L) { return 15; }
  if (v >= 10000000000000L) { return 14; }
  if (v >= 1000000000000L) { return 13; }
  if (v >= 100000000000L) { return 12; }
  if (v >= 10000000000L) { return 11; }
  if (v >= 1000000000L) { return 10; }
  if (v >= 100000000L) { return 9; }
  if (v >= 10000000L) { return 8; }
  if (v >= 1000000L) { return 7; }
  if (v >= 100000L) { return 6; }
  if (v >= 10000L) { return 5; }
  if (v >= 1000L) { return 4; }
  if (v >= 100L) { return 3; }
  if (v >= 10L) { return 2; }
  return 1;
}

#if defined(HAS_64_BIT_INTRINSICS)

#include <intrin.h>

NANOSTL_HOST_AND_DEVICE_QUAL
static inline uint64_t umul128(const uint64_t a, const uint64_t b, uint64_t* const productHi) {
  return _umul128(a, b, productHi);
}

// Returns the lower 64 bits of (hi*2^64 + lo) >> dist, with 0 < dist < 64.
NANOSTL_HOST_AND_DEVICE_QUAL
static inline uint64_t shiftright128(const uint64_t lo, const uint64_t hi, const uint32_t dist) {
  // For the __shiftright128 intrinsic, the shift value is always
  // modulo 64.
  // In the current implementation of the double-precision version
  // of Ryu, the shift value is always < 64. (In the case
  // RYU_OPTIMIZE_SIZE == 0, the shift value is in the range [49, 58].
  // Otherwise in the range [2, 59].)
  // However, this function is now also called by s2d, which requires supporting
  // the larger shift range (TODO: what is the actual range?).
  // Check this here in case a future change requires larger shift
  // values. In this case this function needs to be adjusted.
  assert(dist < 64);
  return __shiftright128(lo, hi, (unsigned char) dist);
}

#else // defined(HAS_64_BIT_INTRINSICS)

NANOSTL_HOST_AND_DEVICE_QUAL
static inline uint64_t umul128(const uint64_t a, const uint64_t b, uint64_t* const productHi) {
  // The casts here help MSVC to avoid calls to the __allmul library function.
  const uint32_t aLo = (uint32_t)a;
  const uint32_t aHi = (uint32_t)(a >> 32);
  const uint32_t bLo = (uint32_t)b;
  const uint32_t bHi = (uint32_t)(b >> 32);

  const uint64_t b00 = (uint64_t)aLo * bLo;
  const uint64_t b01 = (uint64_t)aLo * bHi;
  const uint64_t b10 = (uint64_t)aHi * bLo;
  const uint64_t b11 = (uint64_t)aHi * bHi;

  const uint32_t b00Lo = (uint32_t)b00;
  const uint32_t b00Hi = (uint32_t)(b00 >> 32);

  const uint64_t mid1 = b10 + b00Hi;
  const uint32_t mid1Lo = (uint32_t)(mid1);
  const uint32_t mid1Hi = (uint32_t)(mid1 >> 32);

  const uint64_t mid2 = b01 + mid1Lo;
  const uint32_t mid2Lo = (uint32_t)(mid2);
  const uint32_t mid2Hi = (uint32_t)(mid2 >> 32);

  const uint64_t pHi = b11 + mid1Hi + mid2Hi;
  const uint64_t pLo = ((uint64_t)mid2Lo << 32) | b00Lo;

  *productHi = pHi;
  return pLo;
}

NANOSTL_HOST_AND_DEVICE_QUAL
static inline uint64_t shiftright128(const uint64_t lo, const uint64_t hi, const uint32_t dist) {
  // We don't need to handle the case dist >= 64 here (see above).
  assert(dist < 64);
  assert(dist > 0);
  return (hi << (64 - dist)) | (lo >> dist);
}

#endif // defined(HAS_64_BIT_INTRINSICS)

#if defined(RYU_32_BIT_PLATFORM)

// Returns the high 64 bits of the 128-bit product of a and b.
NANOSTL_HOST_AND_DEVICE_QUAL
static inline uint64_t umulh(const uint64_t a, const uint64_t b) {
  // Reuse the umul128 implementation.
  // Optimizers will likely eliminate the instructions used to compute the
  // low part of the product.
  uint64_t hi;
  umul128(a, b, &hi);
  return hi;
}

// On 32-bit platforms, compilers typically generate calls to library
// functions for 64-bit divisions, even if the divisor is a constant.
//
// E.g.:
// https://bugs.llvm.org/show_bug.cgi?id=37932
// https://gcc.gnu.org/bugzilla/show_bug.cgi?id=17958
// https://gcc.gnu.org/bugzilla/show_bug.cgi?id=37443
//
// The functions here perform division-by-constant using multiplications
// in the same way as 64-bit compilers would do.
//
// NB:
// The multipliers and shift values are the ones generated by clang x64
// for expressions like x/5, x/10, etc.

NANOSTL_HOST_AND_DEVICE_QUAL
static inline uint64_t div5(const uint64_t x) {
  return umulh(x, 0xCCCCCCCCCCCCCCCDu) >> 2;
}

NANOSTL_HOST_AND_DEVICE_QUAL
static inline uint64_t div10(const uint64_t x) {
  return umulh(x, 0xCCCCCCCCCCCCCCCDu) >> 3;
}

NANOSTL_HOST_AND_DEVICE_QUAL
static inline uint64_t div100(const uint64_t x) {
  return umulh(x >> 2, 0x28F5C28F5C28F5C3u) >> 2;
}

NANOSTL_HOST_AND_DEVICE_QUAL
static inline uint64_t div1e8(const uint64_t x) {
  return umulh(x, 0xABCC77118461CEFDu) >> 26;
}

NANOSTL_HOST_AND_DEVICE_QUAL
static inline uint64_t div1e9(const uint64_t x) {
  return umulh(x >> 9, 0x44B82FA09B5A53u) >> 11;
}

NANOSTL_HOST_AND_DEVICE_QUAL
static inline uint32_t mod1e9(const uint64_t x) {
  // Avoid 64-bit math as much as possible.
  // Returning (uint32_t) (x - 1000000000 * div1e9(x)) would
  // perform 32x64-bit multiplication and 64-bit subtraction.
  // x and 1000000000 * div1e9(x) are guaranteed to differ by
  // less than 10^9, so their highest 32 bits must be identical,
  // so we can truncate both sides to uint32_t before subtracting.
  // We can also simplify (uint32_t) (1000000000 * div1e9(x)).
  // We can truncate before multiplying instead of after, as multiplying
  // the highest 32 bits of div1e9(x) can't affect the lowest 32 bits.
  return ((uint32_t) x) - 1000000000 * ((uint32_t) div1e9(x));
}

#else // defined(RYU_32_BIT_PLATFORM)

NANOSTL_HOST_AND_DEVICE_QUAL
static inline uint64_t div5(const uint64_t x) {
  return x / 5;
}

NANOSTL_HOST_AND_DEVICE_QUAL
static inline uint64_t div10(const uint64_t x) {
  return x / 10;
}

NANOSTL_HOST_AND_DEVICE_QUAL
static inline uint64_t div100(const uint64_t x) {
  return x / 100;
}

NANOSTL_HOST_AND_DEVICE_QUAL
static inline uint64_t div1e8(const uint64_t x) {
  return x / 100000000;
}

NANOSTL_HOST_AND_DEVICE_QUAL
static inline uint64_t div1e9(const uint64_t x) {
  return x / 1000000000;
}

NANOSTL_HOST_AND_DEVICE_QUAL
static inline uint32_t mod1e9(const uint64_t x) {
  return (uint32_t) (x - 1000000000 * div1e9(x));
}

#endif // defined(RYU_32_BIT_PLATFORM)

NANOSTL_HOST_AND_DEVICE_QUAL
static inline uint32_t pow5Factor(uint64_t value) {
  uint32_t count = 0;
  for (;;) {
    assert(value != 0);
    const uint64_t q = div5(value);
    const uint32_t r = ((uint32_t) value) - 5 * ((uint32_t) q);
    if (r != 0) {
      break;
    }
    value = q;
    ++count;
  }
  return count;
}

// Returns true if value is divisible by 5^p.
NANOSTL_HOST_AND_DEVICE_QUAL
static inline bool multipleOfPowerOf5(const uint64_t value, const uint32_t p) {
  // I tried a case distinction on p, but there was no performance difference.
  return pow5Factor(value) >= p;
}

// Returns true if value is divisible by 2^p.
NANOSTL_HOST_AND_DEVICE_QUAL
static inline bool multipleOfPowerOf2(const uint64_t value, const uint32_t p) {
  assert(value != 0);
  assert(p < 64);
  // __builtin_ctzll doesn't appear to be faster here.
  return (value & ((1ull << p) - 1)) == 0;
}

// A table of all two-digit numbers. This is used to speed up decimal digit
// generation by copying pairs of digits into the final output.
NANOSTL_HOST_AND_DEVICE_QUAL
static const char DIGIT_TABLE[200] = {
  '0','0','0','1','0','2','0','3','0','4','0','5','0','6','0','7','0','8','0','9',
  '1','0','1','1','1','2','1','3','1','4','1','5','1','6','1','7','1','8','1','9',
  '2','0','2','1','2','2','2','3','2','4','2','5','2','6','2','7','2','8','2','9',
  '3','0','3','1','3','2','3','3','3','4','3','5','3','6','3','7','3','8','3','9',
  '4','0','4','1','4','2','4','3','4','4','4','5','4','6','4','7','4','8','4','9',
  '5','0','5','1','5','2','5','3','5','4','5','5','5','6','5','7','5','8','5','9',
  '6','0','6','1','6','2','6','3','6','4','6','5','6','6','6','7','6','8','6','9',
  '7','0','7','1','7','2','7','3','7','4','7','5','7','6','7','7','7','8','7','9',
  '8','0','8','1','8','2','8','3','8','4','8','5','8','6','8','7','8','8','8','9',
  '9','0','9','1','9','2','9','3','9','4','9','5','9','6','9','7','9','8','9','9'
};

NANOSTL_HOST_AND_DEVICE_QUAL
static inline int copy_special_str(char * const result, const bool sign, const bool exponent, const bool mantissa) {
  if (mantissa) {
    memcpy(result, "NaN", 3);
    return 3;
  }
  if (sign) {
    result[0] = '-';
  }
  if (exponent) {
    memcpy(result + sign, "Infinity", 8);
    return sign + 8;
  }
  memcpy(result + sign, "0E0", 3);
  return sign + 3;
}

NANOSTL_HOST_AND_DEVICE_QUAL
static inline uint32_t float_to_bits(const float f) {
  uint32_t bits = 0;
  memcpy(&bits, &f, sizeof(float));
  return bits;
}

NANOSTL_HOST_AND_DEVICE_QUAL
static inline uint64_t double_to_bits(const double d) {
  uint64_t bits = 0;
  memcpy(&bits, &d, sizeof(double));
  return bits;
}

NANOSTL_HOST_AND_DEVICE_QUAL
static inline int to_chars(const floating_decimal_32 v, const bool sign, char* const result) {
  // Step 5: Print the decimal representation.
  int index = 0;
  if (sign) {
    result[index++] = '-';
  }

  uint32_t output = v.mantissa;
  const uint32_t olength = decimalLength9(output);

#ifdef RYU_DEBUG
  printf("DIGITS=%u\n", v.mantissa);
  printf("OLEN=%u\n", olength);
  printf("EXP=%u\n", v.exponent + olength);
#endif

  // Print the decimal digits.
  // The following code is equivalent to:
  // for (uint32_t i = 0; i < olength - 1; ++i) {
  //   const uint32_t c = output % 10; output /= 10;
  //   result[index + olength - i] = (char) ('0' + c);
  // }
  // result[index] = '0' + output % 10;
  uint32_t i = 0;
  while (output >= 10000) {
#ifdef __clang__ // https://bugs.llvm.org/show_bug.cgi?id=38217
    const uint32_t c = output - 10000 * (output / 10000);
#else
    const uint32_t c = output % 10000;
#endif
    output /= 10000;
    const uint32_t c0 = (c % 100) << 1;
    const uint32_t c1 = (c / 100) << 1;
    memcpy(result + index + olength - i - 1, DIGIT_TABLE + c0, 2);
    memcpy(result + index + olength - i - 3, DIGIT_TABLE + c1, 2);
    i += 4;
  }
  if (output >= 100) {
    const uint32_t c = (output % 100) << 1;
    output /= 100;
    memcpy(result + index + olength - i - 1, DIGIT_TABLE + c, 2);
    i += 2;
  }
  if (output >= 10) {
    const uint32_t c = output << 1;
    // We can't use memcpy here: the decimal dot goes between these two digits.
    result[index + olength - i] = DIGIT_TABLE[c + 1];
    result[index] = DIGIT_TABLE[c];
  } else {
    result[index] = (char) ('0' + output);
  }

  // Print decimal point if needed.
  if (olength > 1) {
    result[index + 1] = '.';
    index += olength + 1;
  } else {
    ++index;
  }

  // Print the exponent.
  result[index++] = 'E';
  int32_t exp = v.exponent + (int32_t) olength - 1;
  if (exp < 0) {
    result[index++] = '-';
    exp = -exp;
  }

  if (exp >= 10) {
    memcpy(result + index, DIGIT_TABLE + 2 * exp, 2);
    index += 2;
  } else {
    result[index++] = (char) ('0' + exp);
  }

  return index;
}

NANOSTL_HOST_AND_DEVICE_QUAL
static int f2s_buffered_n(float f, char* result) {
  // Step 1: Decode the floating-point number, and unify normalized and subnormal cases.
  const uint32_t bits = float_to_bits(f);

#ifdef RYU_DEBUG
  printf("IN=");
  for (int32_t bit = 31; bit >= 0; --bit) {
    printf("%u", (bits >> bit) & 1);
  }
  printf("\n");
#endif

  // Decode bits into sign, mantissa, and exponent.
  const bool ieeeSign = ((bits >> (RYU_FLOAT_MANTISSA_BITS + RYU_FLOAT_EXPONENT_BITS)) & 1) != 0;
  const uint32_t ieeeMantissa = bits & ((1u << RYU_FLOAT_MANTISSA_BITS) - 1);
  const uint32_t ieeeExponent = (bits >> RYU_FLOAT_MANTISSA_BITS) & ((1u << RYU_FLOAT_EXPONENT_BITS) - 1);

  // Case distinction; exit early for the easy cases.
  if (ieeeExponent == ((1u << RYU_FLOAT_EXPONENT_BITS) - 1u) || (ieeeExponent == 0 && ieeeMantissa == 0)) {
    return copy_special_str(result, ieeeSign, ieeeExponent, ieeeMantissa);
  }

  const floating_decimal_32 v = f2d(ieeeMantissa, ieeeExponent);
  return to_chars(v, ieeeSign, result);
}

// result: 16bytes for float
NANOSTL_HOST_AND_DEVICE_QUAL
static void f2s_buffered(float f, char* result) {
  const int index = f2s_buffered_n(f, result);

  // Terminate the string.
  result[index] = '\0';
}

// A floating decimal representing m * 10^e.
typedef struct floating_decimal_64 {
  uint64_t mantissa;
  // Decimal exponent's range is -324 to 308
  // inclusive, and can fit in a short if needed.
  int32_t exponent;
} floating_decimal_64;

NANOSTL_HOST_AND_DEVICE_QUAL
static inline uint64_t mulShift64(const uint64_t m, const uint64_t* const mul, const int32_t j) {
  // m is maximum 55 bits
  uint64_t high1;                                   // 128
  const uint64_t low1 = umul128(m, mul[1], &high1); // 64
  uint64_t high0;                                   // 64
  umul128(m, mul[0], &high0);                       // 0
  const uint64_t sum = high0 + low1;
  if (sum < high0) {
    ++high1; // overflow into high1
  }
  return shiftright128(sum, high1, j - 64);
}

// This is faster if we don't have a 64x64->128-bit multiplication.
NANOSTL_HOST_AND_DEVICE_QUAL
static inline uint64_t mulShiftAll64(uint64_t m, const uint64_t* const mul, const int32_t j,
  uint64_t* const vp, uint64_t* const vm, const uint32_t mmShift) {
  m <<= 1;
  // m is maximum 55 bits
  uint64_t tmp;
  const uint64_t lo = umul128(m, mul[0], &tmp);
  uint64_t hi;
  const uint64_t mid = tmp + umul128(m, mul[1], &hi);
  hi += mid < tmp; // overflow into hi

  const uint64_t lo2 = lo + mul[0];
  const uint64_t mid2 = mid + mul[1] + (lo2 < lo);
  const uint64_t hi2 = hi + (mid2 < mid);
  *vp = shiftright128(mid2, hi2, (uint32_t) (j - 64 - 1));

  if (mmShift == 1) {
    const uint64_t lo3 = lo - mul[0];
    const uint64_t mid3 = mid - mul[1] - (lo3 > lo);
    const uint64_t hi3 = hi - (mid3 > mid);
    *vm = shiftright128(mid3, hi3, (uint32_t) (j - 64 - 1));
  } else {
    const uint64_t lo3 = lo + lo;
    const uint64_t mid3 = mid + mid + (lo3 < lo);
    const uint64_t hi3 = hi + hi + (mid3 < mid);
    const uint64_t lo4 = lo3 - mul[0];
    const uint64_t mid4 = mid3 - mul[1] - (lo4 > lo3);
    const uint64_t hi4 = hi3 - (mid4 > mid3);
    *vm = shiftright128(mid4, hi4, (uint32_t) (j - 64));
  }

  return shiftright128(mid, hi, (uint32_t) (j - 64 - 1));
}

NANOSTL_HOST_AND_DEVICE_QUAL
static inline floating_decimal_64 d2d(const uint64_t ieeeMantissa, const uint32_t ieeeExponent) {
  int32_t e2;
  uint64_t m2;
  if (ieeeExponent == 0) {
    // We subtract 2 so that the bounds computation has 2 additional bits.
    e2 = 1 - RYU_DOUBLE_BIAS - RYU_DOUBLE_MANTISSA_BITS - 2;
    m2 = ieeeMantissa;
  } else {
    e2 = (int32_t) ieeeExponent - RYU_DOUBLE_BIAS - RYU_DOUBLE_MANTISSA_BITS - 2;
    m2 = (1ull << RYU_DOUBLE_MANTISSA_BITS) | ieeeMantissa;
  }
  const bool even = (m2 & 1) == 0;
  const bool acceptBounds = even;

#ifdef RYU_DEBUG
  printf("-> %" PRIu64 " * 2^%d\n", m2, e2 + 2);
#endif

  // Step 2: Determine the interval of valid decimal representations.
  const uint64_t mv = 4 * m2;
  // Implicit bool -> int conversion. True is 1, false is 0.
  const uint32_t mmShift = ieeeMantissa != 0 || ieeeExponent <= 1;
  // We would compute mp and mm like this:
  // uint64_t mp = 4 * m2 + 2;
  // uint64_t mm = mv - 1 - mmShift;

  // Step 3: Convert to a decimal power base using 128-bit arithmetic.
  uint64_t vr, vp, vm;
  int32_t e10;
  bool vmIsTrailingZeros = false;
  bool vrIsTrailingZeros = false;
  if (e2 >= 0) {
    // I tried special-casing q == 0, but there was no effect on performance.
    // This expression is slightly faster than max(0, log10Pow2(e2) - 1).
    const uint32_t q = log10Pow2(e2) - (e2 > 3);
    e10 = (int32_t) q;
    const int32_t k = RYU_DOUBLE_POW5_INV_BITCOUNT + pow5bits((int32_t) q) - 1;
    const int32_t i = -e2 + (int32_t) q + k;
#if defined(RYU_OPTIMIZE_SIZE)
    uint64_t pow5[2];
    double_computeInvPow5(q, pow5);
    vr = mulShiftAll64(m2, pow5, i, &vp, &vm, mmShift);
#else
    vr = mulShiftAll64(m2, DOUBLE_POW5_INV_SPLIT[q], i, &vp, &vm, mmShift);
#endif
#ifdef RYU_DEBUG
    printf("%" PRIu64 " * 2^%d / 10^%u\n", mv, e2, q);
    printf("V+=%" PRIu64 "\nV =%" PRIu64 "\nV-=%" PRIu64 "\n", vp, vr, vm);
#endif
    if (q <= 21) {
      // This should use q <= 22, but I think 21 is also safe. Smaller values
      // may still be safe, but it's more difficult to reason about them.
      // Only one of mp, mv, and mm can be a multiple of 5, if any.
      const uint32_t mvMod5 = ((uint32_t) mv) - 5 * ((uint32_t) div5(mv));
      if (mvMod5 == 0) {
        vrIsTrailingZeros = multipleOfPowerOf5(mv, q);
      } else if (acceptBounds) {
        // Same as min(e2 + (~mm & 1), pow5Factor(mm)) >= q
        // <=> e2 + (~mm & 1) >= q && pow5Factor(mm) >= q
        // <=> true && pow5Factor(mm) >= q, since e2 >= q.
        vmIsTrailingZeros = multipleOfPowerOf5(mv - 1 - mmShift, q);
      } else {
        // Same as min(e2 + 1, pow5Factor(mp)) >= q.
        vp -= multipleOfPowerOf5(mv + 2, q);
      }
    }
  } else {
    // This expression is slightly faster than max(0, log10Pow5(-e2) - 1).
    const uint32_t q = log10Pow5(-e2) - (-e2 > 1);
    e10 = (int32_t) q + e2;
    const int32_t i = -e2 - (int32_t) q;
    const int32_t k = pow5bits(i) - RYU_DOUBLE_POW5_BITCOUNT;
    const int32_t j = (int32_t) q - k;
#if defined(RYU_OPTIMIZE_SIZE)
    uint64_t pow5[2];
    double_computePow5(i, pow5);
    vr = mulShiftAll64(m2, pow5, j, &vp, &vm, mmShift);
#else
    vr = mulShiftAll64(m2, DOUBLE_POW5_SPLIT[i], j, &vp, &vm, mmShift);
#endif
#ifdef RYU_DEBUG
    printf("%" PRIu64 " * 5^%d / 10^%u\n", mv, -e2, q);
    printf("%u %d %d %d\n", q, i, k, j);
    printf("V+=%" PRIu64 "\nV =%" PRIu64 "\nV-=%" PRIu64 "\n", vp, vr, vm);
#endif
    if (q <= 1) {
      // {vr,vp,vm} is trailing zeros if {mv,mp,mm} has at least q trailing 0 bits.
      // mv = 4 * m2, so it always has at least two trailing 0 bits.
      vrIsTrailingZeros = true;
      if (acceptBounds) {
        // mm = mv - 1 - mmShift, so it has 1 trailing 0 bit iff mmShift == 1.
        vmIsTrailingZeros = mmShift == 1;
      } else {
        // mp = mv + 2, so it always has at least one trailing 0 bit.
        --vp;
      }
    } else if (q < 63) { // TODO(ulfjack): Use a tighter bound here.
      // We want to know if the full product has at least q trailing zeros.
      // We need to compute min(p2(mv), p5(mv) - e2) >= q
      // <=> p2(mv) >= q && p5(mv) - e2 >= q
      // <=> p2(mv) >= q (because -e2 >= q)
      vrIsTrailingZeros = multipleOfPowerOf2(mv, q);
#ifdef RYU_DEBUG
      printf("vr is trailing zeros=%s\n", vrIsTrailingZeros ? "true" : "false");
#endif
    }
  }
#ifdef RYU_DEBUG
  printf("e10=%d\n", e10);
  printf("V+=%" PRIu64 "\nV =%" PRIu64 "\nV-=%" PRIu64 "\n", vp, vr, vm);
  printf("vm is trailing zeros=%s\n", vmIsTrailingZeros ? "true" : "false");
  printf("vr is trailing zeros=%s\n", vrIsTrailingZeros ? "true" : "false");
#endif

  // Step 4: Find the shortest decimal representation in the interval of valid representations.
  int32_t removed = 0;
  uint8_t lastRemovedDigit = 0;
  uint64_t output;
  // On average, we remove ~2 digits.
  if (vmIsTrailingZeros || vrIsTrailingZeros) {
    // General case, which happens rarely (~0.7%).
    for (;;) {
      const uint64_t vpDiv10 = div10(vp);
      const uint64_t vmDiv10 = div10(vm);
      if (vpDiv10 <= vmDiv10) {
        break;
      }
      const uint32_t vmMod10 = ((uint32_t) vm) - 10 * ((uint32_t) vmDiv10);
      const uint64_t vrDiv10 = div10(vr);
      const uint32_t vrMod10 = ((uint32_t) vr) - 10 * ((uint32_t) vrDiv10);
      vmIsTrailingZeros &= vmMod10 == 0;
      vrIsTrailingZeros &= lastRemovedDigit == 0;
      lastRemovedDigit = (uint8_t) vrMod10;
      vr = vrDiv10;
      vp = vpDiv10;
      vm = vmDiv10;
      ++removed;
    }
#ifdef RYU_DEBUG
    printf("V+=%" PRIu64 "\nV =%" PRIu64 "\nV-=%" PRIu64 "\n", vp, vr, vm);
    printf("d-10=%s\n", vmIsTrailingZeros ? "true" : "false");
#endif
    if (vmIsTrailingZeros) {
      for (;;) {
        const uint64_t vmDiv10 = div10(vm);
        const uint32_t vmMod10 = ((uint32_t) vm) - 10 * ((uint32_t) vmDiv10);
        if (vmMod10 != 0) {
          break;
        }
        const uint64_t vpDiv10 = div10(vp);
        const uint64_t vrDiv10 = div10(vr);
        const uint32_t vrMod10 = ((uint32_t) vr) - 10 * ((uint32_t) vrDiv10);
        vrIsTrailingZeros &= lastRemovedDigit == 0;
        lastRemovedDigit = (uint8_t) vrMod10;
        vr = vrDiv10;
        vp = vpDiv10;
        vm = vmDiv10;
        ++removed;
      }
    }
#ifdef RYU_DEBUG
    printf("%" PRIu64 " %d\n", vr, lastRemovedDigit);
    printf("vr is trailing zeros=%s\n", vrIsTrailingZeros ? "true" : "false");
#endif
    if (vrIsTrailingZeros && lastRemovedDigit == 5 && vr % 2 == 0) {
      // Round even if the exact number is .....50..0.
      lastRemovedDigit = 4;
    }
    // We need to take vr + 1 if vr is outside bounds or we need to round up.
    output = vr + ((vr == vm && (!acceptBounds || !vmIsTrailingZeros)) || lastRemovedDigit >= 5);
  } else {
    // Specialized for the common case (~99.3%). Percentages below are relative to this.
    bool roundUp = false;
    const uint64_t vpDiv100 = div100(vp);
    const uint64_t vmDiv100 = div100(vm);
    if (vpDiv100 > vmDiv100) { // Optimization: remove two digits at a time (~86.2%).
      const uint64_t vrDiv100 = div100(vr);
      const uint32_t vrMod100 = ((uint32_t) vr) - 100 * ((uint32_t) vrDiv100);
      roundUp = vrMod100 >= 50;
      vr = vrDiv100;
      vp = vpDiv100;
      vm = vmDiv100;
      removed += 2;
    }
    // Loop iterations below (approximately), without optimization above:
    // 0: 0.03%, 1: 13.8%, 2: 70.6%, 3: 14.0%, 4: 1.40%, 5: 0.14%, 6+: 0.02%
    // Loop iterations below (approximately), with optimization above:
    // 0: 70.6%, 1: 27.8%, 2: 1.40%, 3: 0.14%, 4+: 0.02%
    for (;;) {
      const uint64_t vpDiv10 = div10(vp);
      const uint64_t vmDiv10 = div10(vm);
      if (vpDiv10 <= vmDiv10) {
        break;
      }
      const uint64_t vrDiv10 = div10(vr);
      const uint32_t vrMod10 = ((uint32_t) vr) - 10 * ((uint32_t) vrDiv10);
      roundUp = vrMod10 >= 5;
      vr = vrDiv10;
      vp = vpDiv10;
      vm = vmDiv10;
      ++removed;
    }
#ifdef RYU_DEBUG
    printf("%" PRIu64 " roundUp=%s\n", vr, roundUp ? "true" : "false");
    printf("vr is trailing zeros=%s\n", vrIsTrailingZeros ? "true" : "false");
#endif
    // We need to take vr + 1 if vr is outside bounds or we need to round up.
    output = vr + (vr == vm || roundUp);
  }
  const int32_t exp = e10 + removed;

#ifdef RYU_DEBUG
  printf("V+=%" PRIu64 "\nV =%" PRIu64 "\nV-=%" PRIu64 "\n", vp, vr, vm);
  printf("O=%" PRIu64 "\n", output);
  printf("EXP=%d\n", exp);
#endif

  floating_decimal_64 fd;
  fd.exponent = exp;
  fd.mantissa = output;
  return fd;
}

NANOSTL_HOST_AND_DEVICE_QUAL
static inline int to_chars(const floating_decimal_64 v, const bool sign, char* const result) {
  // Step 5: Print the decimal representation.
  int index = 0;
  if (sign) {
    result[index++] = '-';
  }

  uint64_t output = v.mantissa;
  const uint32_t olength = decimalLength17(output);

#ifdef RYU_DEBUG
  printf("DIGITS=%" PRIu64 "\n", v.mantissa);
  printf("OLEN=%u\n", olength);
  printf("EXP=%u\n", v.exponent + olength);
#endif

  // Print the decimal digits.
  // The following code is equivalent to:
  // for (uint32_t i = 0; i < olength - 1; ++i) {
  //   const uint32_t c = output % 10; output /= 10;
  //   result[index + olength - i] = (char) ('0' + c);
  // }
  // result[index] = '0' + output % 10;

  uint32_t i = 0;
  // We prefer 32-bit operations, even on 64-bit platforms.
  // We have at most 17 digits, and uint32_t can store 9 digits.
  // If output doesn't fit into uint32_t, we cut off 8 digits,
  // so the rest will fit into uint32_t.
  if ((output >> 32) != 0) {
    // Expensive 64-bit division.
    const uint64_t q = div1e8(output);
    uint32_t output2 = ((uint32_t) output) - 100000000 * ((uint32_t) q);
    output = q;

    const uint32_t c = output2 % 10000;
    output2 /= 10000;
    const uint32_t d = output2 % 10000;
    const uint32_t c0 = (c % 100) << 1;
    const uint32_t c1 = (c / 100) << 1;
    const uint32_t d0 = (d % 100) << 1;
    const uint32_t d1 = (d / 100) << 1;
    memcpy(result + index + olength - i - 1, DIGIT_TABLE + c0, 2);
    memcpy(result + index + olength - i - 3, DIGIT_TABLE + c1, 2);
    memcpy(result + index + olength - i - 5, DIGIT_TABLE + d0, 2);
    memcpy(result + index + olength - i - 7, DIGIT_TABLE + d1, 2);
    i += 8;
  }
  uint32_t output2 = (uint32_t) output;
  while (output2 >= 10000) {
#ifdef __clang__ // https://bugs.llvm.org/show_bug.cgi?id=38217
    const uint32_t c = output2 - 10000 * (output2 / 10000);
#else
    const uint32_t c = output2 % 10000;
#endif
    output2 /= 10000;
    const uint32_t c0 = (c % 100) << 1;
    const uint32_t c1 = (c / 100) << 1;
    memcpy(result + index + olength - i - 1, DIGIT_TABLE + c0, 2);
    memcpy(result + index + olength - i - 3, DIGIT_TABLE + c1, 2);
    i += 4;
  }
  if (output2 >= 100) {
    const uint32_t c = (output2 % 100) << 1;
    output2 /= 100;
    memcpy(result + index + olength - i - 1, DIGIT_TABLE + c, 2);
    i += 2;
  }
  if (output2 >= 10) {
    const uint32_t c = output2 << 1;
    // We can't use memcpy here: the decimal dot goes between these two digits.
    result[index + olength - i] = DIGIT_TABLE[c + 1];
    result[index] = DIGIT_TABLE[c];
  } else {
    result[index] = (char) ('0' + output2);
  }

  // Print decimal point if needed.
  if (olength > 1) {
    result[index + 1] = '.';
    index += olength + 1;
  } else {
    ++index;
  }

  // Print the exponent.
  result[index++] = 'E';
  int32_t exp = v.exponent + (int32_t) olength - 1;
  if (exp < 0) {
    result[index++] = '-';
    exp = -exp;
  }

  if (exp >= 100) {
    const int32_t c = exp % 10;
    memcpy(result + index, DIGIT_TABLE + 2 * (exp / 10), 2);
    result[index + 2] = (char) ('0' + c);
    index += 3;
  } else if (exp >= 10) {
    memcpy(result + index, DIGIT_TABLE + 2 * exp, 2);
    index += 2;
  } else {
    result[index++] = (char) ('0' + exp);
  }

  return index;
}

NANOSTL_HOST_AND_DEVICE_QUAL
static inline bool d2d_small_int(const uint64_t ieeeMantissa, const uint32_t ieeeExponent,
  floating_decimal_64* const v) {
  const uint64_t m2 = (1ull << RYU_DOUBLE_MANTISSA_BITS) | ieeeMantissa;
  const int32_t e2 = (int32_t) ieeeExponent - RYU_DOUBLE_BIAS - RYU_DOUBLE_MANTISSA_BITS;

  if (e2 > 0) {
    // f = m2 * 2^e2 >= 2^53 is an integer.
    // Ignore this case for now.
    return false;
  }

  if (e2 < -52) {
    // f < 1.
    return false;
  }

  // Since 2^52 <= m2 < 2^53 and 0 <= -e2 <= 52: 1 <= f = m2 / 2^-e2 < 2^53.
  // Test if the lower -e2 bits of the significand are 0, i.e. whether the fraction is 0.
  const uint64_t mask = (1ull << -e2) - 1;
  const uint64_t fraction = m2 & mask;
  if (fraction != 0) {
    return false;
  }

  // f is an integer in the range [1, 2^53).
  // Note: mantissa might contain trailing (decimal) 0's.
  // Note: since 2^53 < 10^16, there is no need to adjust decimalLength17().
  v->mantissa = m2 >> -e2;
  v->exponent = 0;
  return true;
}

NANOSTL_HOST_AND_DEVICE_QUAL
static int d2s_buffered_n(double f, char* result) {
  // Step 1: Decode the floating-point number, and unify normalized and subnormal cases.
  const uint64_t bits = double_to_bits(f);

#ifdef RYU_DEBUG
  printf("IN=");
  for (int32_t bit = 63; bit >= 0; --bit) {
    printf("%d", (int) ((bits >> bit) & 1));
  }
  printf("\n");
#endif

  // Decode bits into sign, mantissa, and exponent.
  const bool ieeeSign = ((bits >> (RYU_DOUBLE_MANTISSA_BITS + RYU_DOUBLE_EXPONENT_BITS)) & 1) != 0;
  const uint64_t ieeeMantissa = bits & ((1ull << RYU_DOUBLE_MANTISSA_BITS) - 1);
  const uint32_t ieeeExponent = (uint32_t) ((bits >> RYU_DOUBLE_MANTISSA_BITS) & ((1u << RYU_DOUBLE_EXPONENT_BITS) - 1));
  // Case distinction; exit early for the easy cases.
  if (ieeeExponent == ((1u << RYU_DOUBLE_EXPONENT_BITS) - 1u) || (ieeeExponent == 0 && ieeeMantissa == 0)) {
    return copy_special_str(result, ieeeSign, ieeeExponent, ieeeMantissa);
  }

  floating_decimal_64 v;
  const bool isSmallInt = d2d_small_int(ieeeMantissa, ieeeExponent, &v);
  if (isSmallInt) {
    // For small integers in the range [1, 2^53), v.mantissa might contain trailing (decimal) zeros.
    // For scientific notation we need to move these zeros into the exponent.
    // (This is not needed for fixed-point notation, so it might be beneficial to trim
    // trailing zeros in to_chars only if needed - once fixed-point notation output is implemented.)
    for (;;) {
      const uint64_t q = div10(v.mantissa);
      const uint32_t r = ((uint32_t) v.mantissa) - 10 * ((uint32_t) q);
      if (r != 0) {
        break;
      }
      v.mantissa = q;
      ++v.exponent;
    }
  } else {
    v = d2d(ieeeMantissa, ieeeExponent);
  }

  return to_chars(v, ieeeSign, result);
}

// bufsize max: 25
NANOSTL_HOST_AND_DEVICE_QUAL
static void d2s_buffered(double f, char* result) {
  const int index = d2s_buffered_n(f, result);

  // Terminate the string.
  result[index] = '\0';
}

//
// ryu_parse.h
//

enum RyuStatus {
  RYU_SUCCESS,
  RYU_INPUT_TOO_SHORT,
  RYU_INPUT_TOO_LONG,
  RYU_MALFORMED_INPUT
};

// Simple clz implementation
// https://stackoverflow.com/questions/23856596/how-to-count-leading-zeros-in-a-32-bit-unsigned-integer

NANOSTL_HOST_AND_DEVICE_QUAL
inline int __myclzi(uint32_t x)
{
  if (!x) return 32;

  int n = 32;
  unsigned y;

  y = x >>16; if (y != 0) { n = n -16; x = y; }
  y = x >> 8; if (y != 0) { n = n - 8; x = y; }
  y = x >> 4; if (y != 0) { n = n - 4; x = y; }
  y = x >> 2; if (y != 0) { n = n - 2; x = y; }
  y = x >> 1; if (y != 0) return n - 2;
  return n - x;

}

NANOSTL_HOST_AND_DEVICE_QUAL
inline uint32_t floor_log2(const uint32_t value) {
  if (value == 0) return 32;

  return 31 - __myclzi(value);
}

// The max function is already defined on Windows.
NANOSTL_HOST_AND_DEVICE_QUAL
inline int32_t max32(int32_t a, int32_t b) {
  return a < b ? b : a;
}

NANOSTL_HOST_AND_DEVICE_QUAL
inline float int32Bits2Float(uint32_t bits) {
  float f;
  memcpy(&f, &bits, sizeof(float));
  return f;
}

NANOSTL_HOST_AND_DEVICE_QUAL
static enum RyuStatus s2f_n(const char * buffer, const int len, float * result) {
  if (len == 0) {
    return RYU_INPUT_TOO_SHORT;
  }
  int m10digits = 0;
  int e10digits = 0;
  int dotIndex = len;
  int eIndex = len;
  uint32_t m10 = 0;
  int32_t e10 = 0;
  bool signedM = false;
  bool signedE = false;
  int i = 0;
  if (buffer[i] == '-') {
    signedM = true;
    i++;
  }
  for (; i < len; i++) {
    char c = buffer[i];
    if (c == '.') {
      if (dotIndex != len) {
        return RYU_MALFORMED_INPUT;
      }
      dotIndex = i;
      continue;
    }
    if ((c < '0') || (c > '9')) {
      break;
    }
    if (m10digits >= 9) {
      return RYU_INPUT_TOO_LONG;
    }
    m10 = 10 * m10 + (c - '0');
    if (m10 != 0) {
      m10digits++;
    }
  }
  if (i < len && ((buffer[i] == 'e') || (buffer[i] == 'E'))) {
    eIndex = i;
    i++;
    if (i < len && ((buffer[i] == '-') || (buffer[i] == '+'))) {
      signedE = buffer[i] == '-';
      i++;
    }
    for (; i < len; i++) {
      char c = buffer[i];
      if ((c < '0') || (c > '9')) {
        return RYU_MALFORMED_INPUT;
      }
      if (e10digits > 3) {
        // TODO: Be more lenient. Return +/-Infinity or +/-0 instead.
        return RYU_INPUT_TOO_LONG;
      }
      e10 = 10 * e10 + (c - '0');
      if (e10 != 0) {
        e10digits++;
      }
    }
  }
  if (i < len) {
    return RYU_MALFORMED_INPUT;
  }
  if (signedE) {
    e10 = -e10;
  }
  e10 -= dotIndex < eIndex ? eIndex - dotIndex - 1 : 0;
  if (m10 == 0) {
    *result = signedM ? -0.0f : 0.0f;
    return RYU_SUCCESS;
  }

#ifdef RYU_DEBUG
  printf("Input=%s\n", buffer);
  printf("m10digits = %d\n", m10digits);
  printf("e10digits = %d\n", e10digits);
  printf("m10 * 10^e10 = %u * 10^%d\n", m10, e10);
#endif

  if ((m10digits + e10 <= -46) || (m10 == 0)) {
    // Number is less than 1e-46, which should be rounded down to 0; return +/-0.0.
    uint32_t ieee = ((uint32_t) signedM) << (RYU_FLOAT_EXPONENT_BITS + RYU_FLOAT_MANTISSA_BITS);
    *result = int32Bits2Float(ieee);
    return RYU_SUCCESS;
  }
  if (m10digits + e10 >= 40) {
    // Number is larger than 1e+39, which should be rounded to +/-Infinity.
    uint32_t ieee = (((uint32_t) signedM) << (RYU_FLOAT_EXPONENT_BITS + RYU_FLOAT_MANTISSA_BITS)) | (0xffu << RYU_FLOAT_MANTISSA_BITS);
    *result = int32Bits2Float(ieee);
    return RYU_SUCCESS;
  }

  // Convert to binary float m2 * 2^e2, while retaining information about whether the conversion
  // was exact (trailingZeros).
  int32_t e2;
  uint32_t m2;
  bool trailingZeros;
  if (e10 >= 0) {
    // The length of m * 10^e in bits is:
    //   log2(m10 * 10^e10) = log2(m10) + e10 log2(10) = log2(m10) + e10 + e10 * log2(5)
    //
    // We want to compute the FLOAT_MANTISSA_BITS + 1 top-most bits (+1 for the implicit leading
    // one in IEEE format). We therefore choose a binary output exponent of
    //   log2(m10 * 10^e10) - (FLOAT_MANTISSA_BITS + 1).
    //
    // We use floor(log2(5^e10)) so that we get at least this many bits; better to
    // have an additional bit than to not have enough bits.
    e2 = floor_log2(m10) + e10 + log2pow5(e10) - (RYU_FLOAT_MANTISSA_BITS + 1);

    // We now compute [m10 * 10^e10 / 2^e2] = [m10 * 5^e10 / 2^(e2-e10)].
    // To that end, we use the FLOAT_POW5_SPLIT table.
    int j = e2 - e10 - ceil_log2pow5(e10) + RYU_FLOAT_POW5_BITCOUNT;
    assert(j >= 0);
    m2 = mulPow5divPow2(m10, e10, j);

    // We also compute if the result is exact, i.e.,
    //   [m10 * 10^e10 / 2^e2] == m10 * 10^e10 / 2^e2.
    // This can only be the case if 2^e2 divides m10 * 10^e10, which in turn requires that the
    // largest power of 2 that divides m10 + e10 is greater than e2. If e2 is less than e10, then
    // the result must be exact. Otherwise we use the existing multipleOfPowerOf2 function.
    trailingZeros = e2 < e10 || (e2 - e10 < 32 && multipleOfPowerOf2_32(m10, e2 - e10));
  } else {
    e2 = floor_log2(m10) + e10 - ceil_log2pow5(-e10) - (RYU_FLOAT_MANTISSA_BITS + 1);

    // We now compute [m10 * 10^e10 / 2^e2] = [m10 / (5^(-e10) 2^(e2-e10))].
    int j = e2 - e10 + ceil_log2pow5(-e10) - 1 + RYU_FLOAT_POW5_INV_BITCOUNT;
    m2 = mulPow5InvDivPow2(m10, -e10, j);

    // We also compute if the result is exact, i.e.,
    //   [m10 / (5^(-e10) 2^(e2-e10))] == m10 / (5^(-e10) 2^(e2-e10))
    //
    // If e2-e10 >= 0, we need to check whether (5^(-e10) 2^(e2-e10)) divides m10, which is the
    // case iff pow5(m10) >= -e10 AND pow2(m10) >= e2-e10.
    //
    // If e2-e10 < 0, we have actually computed [m10 * 2^(e10 e2) / 5^(-e10)] above,
    // and we need to check whether 5^(-e10) divides (m10 * 2^(e10-e2)), which is the case iff
    // pow5(m10 * 2^(e10-e2)) = pow5(m10) >= -e10.
    trailingZeros = (e2 < e10 || (e2 - e10 < 32 && multipleOfPowerOf2_32(m10, e2 - e10)))
        && multipleOfPowerOf5_32(m10, -e10);
  }

#ifdef RYU_DEBUG
  printf("m2 * 2^e2 = %u * 2^%d\n", m2, e2);
#endif

  // Compute the final IEEE exponent.
  uint32_t ieee_e2 = (uint32_t) max32(0, e2 + RYU_FLOAT_EXPONENT_BIAS + floor_log2(m2));

  if (ieee_e2 > 0xfe) {
    // Final IEEE exponent is larger than the maximum representable; return +/-Infinity.
    uint32_t ieee = (((uint32_t) signedM) << (RYU_FLOAT_EXPONENT_BITS + RYU_FLOAT_MANTISSA_BITS)) | (0xffu << RYU_FLOAT_MANTISSA_BITS);
    *result = int32Bits2Float(ieee);
    return RYU_SUCCESS;
  }

  // We need to figure out how much we need to shift m2. The tricky part is that we need to take
  // the final IEEE exponent into account, so we need to reverse the bias and also special-case
  // the value 0.
  int32_t shift = (ieee_e2 == 0 ? 1 : ieee_e2) - e2 - RYU_FLOAT_EXPONENT_BIAS - RYU_FLOAT_MANTISSA_BITS;
  assert(shift >= 0);
#ifdef RYU_DEBUG
  printf("ieee_e2 = %d\n", ieee_e2);
  printf("shift = %d\n", shift);
#endif

  // We need to round up if the exact value is more than 0.5 above the value we computed. That's
  // equivalent to checking if the last removed bit was 1 and either the value was not just
  // trailing zeros or the result would otherwise be odd.
  //
  // We need to update trailingZeros given that we have the exact output exponent ieee_e2 now.
  trailingZeros &= (m2 & ((1u << (shift - 1)) - 1)) == 0;
  uint32_t lastRemovedBit = (m2 >> (shift - 1)) & 1;
  bool roundUp = (lastRemovedBit != 0) && (!trailingZeros || (((m2 >> shift) & 1) != 0));

#ifdef RYU_DEBUG
  printf("roundUp = %d\n", roundUp);
  printf("ieee_m2 = %u\n", (m2 >> shift) + roundUp);
#endif
  uint32_t ieee_m2 = (m2 >> shift) + roundUp;
  assert(ieee_m2 <= (1u << (RYU_FLOAT_MANTISSA_BITS + 1)));
  ieee_m2 &= (1u << RYU_FLOAT_MANTISSA_BITS) - 1;
  if (ieee_m2 == 0 && roundUp) {
    // Rounding up may overflow the mantissa.
    // In this case we move a trailing zero of the mantissa into the exponent.
    // Due to how the IEEE represents +/-Infinity, we don't need to check for overflow here.
    ieee_e2++;
  }
  uint32_t ieee = (((((uint32_t) signedM) << RYU_FLOAT_EXPONENT_BITS) | (uint32_t)ieee_e2) << RYU_FLOAT_MANTISSA_BITS) | ieee_m2;
  *result = int32Bits2Float(ieee);
  return RYU_SUCCESS;
}

// naiive implementation of __clzll
// http://rapidjson.org/clzll_8h_source.html
NANOSTL_HOST_AND_DEVICE_QUAL
inline uint32_t __myclzll(uint64_t x)
{
  if (x == 0) return 64;

  uint32_t r = 0;
  while (!(x & (static_cast<uint64_t>(1) << 63))) {
      x <<= 1;
      ++r;
  }

  return r;
}

NANOSTL_HOST_AND_DEVICE_QUAL
static inline uint32_t floor_log2(const uint64_t value) {
  // assume value != 0
  return 63 - __myclzll(value);
}

NANOSTL_HOST_AND_DEVICE_QUAL
inline double int64Bits2Double(uint64_t bits) {
  double f;
  memcpy(&f, &bits, sizeof(double));
  return f;
}

NANOSTL_HOST_AND_DEVICE_QUAL
static enum RyuStatus s2d_n(const char * buffer, const int len, double * result) {
  if (len == 0) {
    return RYU_INPUT_TOO_SHORT;
  }
  int m10digits = 0;
  int e10digits = 0;
  int dotIndex = len;
  int eIndex = len;
  uint64_t m10 = 0;
  int32_t e10 = 0;
  bool signedM = false;
  bool signedE = false;
  int i = 0;
  if (buffer[i] == '-') {
    signedM = true;
    i++;
  }
  for (; i < len; i++) {
    char c = buffer[i];
    if (c == '.') {
      if (dotIndex != len) {
        return RYU_MALFORMED_INPUT;
      }
      dotIndex = i;
      continue;
    }
    if ((c < '0') || (c > '9')) {
      break;
    }
    if (m10digits >= 17) {
      return RYU_INPUT_TOO_LONG;
    }
    m10 = 10 * m10 + (c - '0');
    if (m10 != 0) {
      m10digits++;
    }
  }
  if (i < len && ((buffer[i] == 'e') || (buffer[i] == 'E'))) {
    eIndex = i;
    i++;
    if (i < len && ((buffer[i] == '-') || (buffer[i] == '+'))) {
      signedE = buffer[i] == '-';
      i++;
    }
    for (; i < len; i++) {
      char c = buffer[i];
      if ((c < '0') || (c > '9')) {
        return RYU_MALFORMED_INPUT;
      }
      if (e10digits > 3) {
        // TODO: Be more lenient. Return +/-Infinity or +/-0 instead.
        return RYU_INPUT_TOO_LONG;
      }
      e10 = 10 * e10 + (c - '0');
      if (e10 != 0) {
        e10digits++;
      }
    }
  }
  if (i < len) {
    return RYU_MALFORMED_INPUT;
  }
  if (signedE) {
    e10 = -e10;
  }
  e10 -= dotIndex < eIndex ? eIndex - dotIndex - 1 : 0;
  if (m10 == 0) {
    *result = signedM ? -0.0 : 0.0;
    return RYU_SUCCESS;
  }

#ifdef RYU_DEBUG
  printf("Input=%s\n", buffer);
  printf("m10digits = %d\n", m10digits);
  printf("e10digits = %d\n", e10digits);
  printf("m10 * 10^e10 = %" PRIu64 " * 10^%d\n", m10, e10);
#endif

  if ((m10digits + e10 <= -324) || (m10 == 0)) {
    // Number is less than 1e-324, which should be rounded down to 0; return +/-0.0.
    uint64_t ieee = ((uint64_t) signedM) << (RYU_DOUBLE_EXPONENT_BITS + RYU_DOUBLE_MANTISSA_BITS);
    *result = int64Bits2Double(ieee);
    return RYU_SUCCESS;
  }
  if (m10digits + e10 >= 310) {
    // Number is larger than 1e+309, which should be rounded to +/-Infinity.
    uint64_t ieee = (((uint64_t) signedM) << (RYU_DOUBLE_EXPONENT_BITS + RYU_DOUBLE_MANTISSA_BITS)) | (0x7ffull << RYU_DOUBLE_MANTISSA_BITS);
    *result = int64Bits2Double(ieee);
    return RYU_SUCCESS;
  }

  // Convert to binary float m2 * 2^e2, while retaining information about whether the conversion
  // was exact (trailingZeros).
  int32_t e2;
  uint64_t m2;
  bool trailingZeros;
  if (e10 >= 0) {
    // The length of m * 10^e in bits is:
    //   log2(m10 * 10^e10) = log2(m10) + e10 log2(10) = log2(m10) + e10 + e10 * log2(5)
    //
    // We want to compute the DOUBLE_MANTISSA_BITS + 1 top-most bits (+1 for the implicit leading
    // one in IEEE format). We therefore choose a binary output exponent of
    //   log2(m10 * 10^e10) - (DOUBLE_MANTISSA_BITS + 1).
    //
    // We use floor(log2(5^e10)) so that we get at least this many bits; better to
    // have an additional bit than to not have enough bits.
    e2 = floor_log2(m10) + e10 + log2pow5(e10) - (RYU_DOUBLE_MANTISSA_BITS + 1);

    // We now compute [m10 * 10^e10 / 2^e2] = [m10 * 5^e10 / 2^(e2-e10)].
    // To that end, we use the DOUBLE_POW5_SPLIT table.
    int j = e2 - e10 - ceil_log2pow5(e10) + RYU_DOUBLE_POW5_BITCOUNT;
    assert(j >= 0);
#if defined(RYU_OPTIMIZE_SIZE)
    uint64_t pow5[2];
    double_computePow5(e10, pow5);
    m2 = mulShift64(m10, pow5, j);
#else
    assert(e10 < RYU_DOUBLE_POW5_TABLE_SIZE);
    m2 = mulShift64(m10, DOUBLE_POW5_SPLIT[e10], j);
#endif
    // We also compute if the result is exact, i.e.,
    //   [m10 * 10^e10 / 2^e2] == m10 * 10^e10 / 2^e2.
    // This can only be the case if 2^e2 divides m10 * 10^e10, which in turn requires that the
    // largest power of 2 that divides m10 + e10 is greater than e2. If e2 is less than e10, then
    // the result must be exact. Otherwise we use the existing multipleOfPowerOf2 function.
    trailingZeros = e2 < e10 || (e2 - e10 < 64 && multipleOfPowerOf2(m10, e2 - e10));
  } else {
    e2 = floor_log2(m10) + e10 - ceil_log2pow5(-e10) - (RYU_DOUBLE_MANTISSA_BITS + 1);
    int j = e2 - e10 + ceil_log2pow5(-e10) - 1 + RYU_DOUBLE_POW5_INV_BITCOUNT;
#if defined(RYU_OPTIMIZE_SIZE)
    uint64_t pow5[2];
    double_computeInvPow5(-e10, pow5);
    m2 = mulShift64(m10, pow5, j);
#else
    assert(-e10 < RYU_DOUBLE_POW5_INV_TABLE_SIZE);
    m2 = mulShift64(m10, DOUBLE_POW5_INV_SPLIT[-e10], j);
#endif
    trailingZeros = multipleOfPowerOf5(m10, -e10);
  }

#ifdef RYU_DEBUG
  printf("m2 * 2^e2 = %" PRIu64 " * 2^%d\n", m2, e2);
#endif

  // Compute the final IEEE exponent.
  uint32_t ieee_e2 = (uint32_t) max32(0, e2 + RYU_DOUBLE_EXPONENT_BIAS + floor_log2(m2));

  if (ieee_e2 > 0x7fe) {
    // Final IEEE exponent is larger than the maximum representable; return +/-Infinity.
    uint64_t ieee = (((uint64_t) signedM) << (RYU_DOUBLE_EXPONENT_BITS + RYU_DOUBLE_MANTISSA_BITS)) | (0x7ffull << RYU_DOUBLE_MANTISSA_BITS);
    *result = int64Bits2Double(ieee);
    return RYU_SUCCESS;
  }

  // We need to figure out how much we need to shift m2. The tricky part is that we need to take
  // the final IEEE exponent into account, so we need to reverse the bias and also special-case
  // the value 0.
  int32_t shift = (ieee_e2 == 0 ? 1 : ieee_e2) - e2 - RYU_DOUBLE_EXPONENT_BIAS - RYU_DOUBLE_MANTISSA_BITS;
  assert(shift >= 0);
#ifdef RYU_DEBUG
  printf("ieee_e2 = %d\n", ieee_e2);
  printf("shift = %d\n", shift);
#endif

  // We need to round up if the exact value is more than 0.5 above the value we computed. That's
  // equivalent to checking if the last removed bit was 1 and either the value was not just
  // trailing zeros or the result would otherwise be odd.
  //
  // We need to update trailingZeros given that we have the exact output exponent ieee_e2 now.
  trailingZeros &= (m2 & ((1ull << (shift - 1)) - 1)) == 0;
  uint64_t lastRemovedBit = (m2 >> (shift - 1)) & 1;
  bool roundUp = (lastRemovedBit != 0) && (!trailingZeros || (((m2 >> shift) & 1) != 0));

#ifdef RYU_DEBUG
  printf("roundUp = %d\n", roundUp);
  printf("ieee_m2 = %" PRIu64 "\n", (m2 >> shift) + roundUp);
#endif
  uint64_t ieee_m2 = (m2 >> shift) + roundUp;
  assert(ieee_m2 <= (1ull << (RYU_DOUBLE_MANTISSA_BITS + 1)));
  ieee_m2 &= (1ull << RYU_DOUBLE_MANTISSA_BITS) - 1;
  if (ieee_m2 == 0 && roundUp) {
    // Due to how the IEEE represents +/-Infinity, we don't need to check for overflow here.
    ieee_e2++;
  }

  uint64_t ieee = (((((uint64_t) signedM) << RYU_DOUBLE_EXPONENT_BITS) | (uint64_t)ieee_e2) << RYU_DOUBLE_MANTISSA_BITS) | ieee_m2;
  *result = int64Bits2Double(ieee);
  return RYU_SUCCESS;
}

//
// ========================================================
//

} // namespace

} // namespace nanostl

// #included from: nanolimits.h

#define NANOSTL_LIMITS_H_

#ifdef NANOSTL_DEBUG
#include <iostream>
#endif

#ifdef __clang__
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wc99-extensions"
#endif

namespace nanostl {

template <class T>
struct numeric_limits;

template <>
struct numeric_limits<bool> {
  NANOSTL_HOST_AND_DEVICE_QUAL
  static inline bool min(void) { return false; }
  NANOSTL_HOST_AND_DEVICE_QUAL
  static inline bool max(void) { return true; }
  NANOSTL_HOST_AND_DEVICE_QUAL
  static inline bool epsilon(void) { return false; }
  static const int digits10 = 0;
};

template <>
struct numeric_limits<char> {
  NANOSTL_HOST_AND_DEVICE_QUAL
  static inline char min(void) { return -128; }
  NANOSTL_HOST_AND_DEVICE_QUAL
  static inline char max(void) { return 127; }
  NANOSTL_HOST_AND_DEVICE_QUAL
  static inline char epsilon(void) { return 0; }
  static const int digits10 = 2;
};

template <>
struct numeric_limits<unsigned char> {
  NANOSTL_HOST_AND_DEVICE_QUAL
  static inline unsigned char min(void) { return 0; }
  NANOSTL_HOST_AND_DEVICE_QUAL
  static inline unsigned char max(void) { return 255; }
  NANOSTL_HOST_AND_DEVICE_QUAL
  static inline unsigned char epsilon(void) { return 0; }
  static const int digits10 = 2;
};

template <>
struct numeric_limits<short> {
  NANOSTL_HOST_AND_DEVICE_QUAL
  static inline short min(void) { return -32768; }
  NANOSTL_HOST_AND_DEVICE_QUAL
  static inline short max(void) { return 32767; }
  NANOSTL_HOST_AND_DEVICE_QUAL
  static inline short epsilon(void) { return 0; }
  static const int digits10 = 4;
};

template <>
struct numeric_limits<unsigned short> {
  NANOSTL_HOST_AND_DEVICE_QUAL
  static inline unsigned short min(void) { return 0; }
  NANOSTL_HOST_AND_DEVICE_QUAL
  static inline unsigned short max(void) { return 65535; }
  NANOSTL_HOST_AND_DEVICE_QUAL
  static inline unsigned short epsilon(void) { return 0; }
  static const int digits10 = 4;
};

template <>
struct numeric_limits<int> {
  NANOSTL_HOST_AND_DEVICE_QUAL
  static inline int min(void) { return -2147483648; }
  NANOSTL_HOST_AND_DEVICE_QUAL
  static inline int max(void) { return 2147483647; }
  NANOSTL_HOST_AND_DEVICE_QUAL
  static inline int epsilon(void) { return 0; }
  static const int digits10 = 9;
};

template <>
struct numeric_limits<unsigned int> {
  NANOSTL_HOST_AND_DEVICE_QUAL
  static inline unsigned int min(void) { return 0; }
  NANOSTL_HOST_AND_DEVICE_QUAL
  static inline unsigned int max(void) { return 0xffffffffU; }
  NANOSTL_HOST_AND_DEVICE_QUAL
  static inline unsigned int epsilon(void) { return 0; }
  static const int digits10 = 9;
};

// assume int64_t
template <>
struct numeric_limits<long long> {
  NANOSTL_HOST_AND_DEVICE_QUAL
  static inline long long min(void) { return (-0x7FFFFFFFFFFFFFFFLL - 1LL); }
  NANOSTL_HOST_AND_DEVICE_QUAL
  static inline long long max(void) { return 0x7FFFFFFFFFFFFFFFLL; }
  NANOSTL_HOST_AND_DEVICE_QUAL
  static inline long long epsilon(void) { return 0; }
  static const int digits10 = 18;
};

// assume uint64_t
template <>
struct numeric_limits<unsigned long long> {
  NANOSTL_HOST_AND_DEVICE_QUAL
  static inline unsigned long long min(void) { return 0; }
  NANOSTL_HOST_AND_DEVICE_QUAL
  static inline unsigned long long max(void) { return 0xFFFFFFFFFFFFFFFFULL; }
  NANOSTL_HOST_AND_DEVICE_QUAL
  static inline unsigned long long epsilon(void) { return 0; }
  static const int digits10 = 19;
};

template <>
struct numeric_limits<float> {
  NANOSTL_HOST_AND_DEVICE_QUAL
  static inline float min(void) { return (1.17549435E-38f); }  // 0x1.0p-126f
  NANOSTL_HOST_AND_DEVICE_QUAL
  static inline float max(void) {
    return (3.402823466e+38F);
  }  // 0x1.fffffep127f
  NANOSTL_HOST_AND_DEVICE_QUAL
  static inline float epsilon(void) { return (1.19209290E-07f); }  // 0x1.0p-23f

  NANOSTL_HOST_AND_DEVICE_QUAL
  static inline float denorm_min(void) {
    IEEE754Float flt;
    flt.bits.sign = 0;
    flt.bits.exponent = 0;
    flt.bits.mantissa = 1;

    return flt.f;
  }

  NANOSTL_HOST_AND_DEVICE_QUAL
  static inline float infinity(void) {
    IEEE754Float flt;
    flt.bits.exponent = 255;
    flt.bits.mantissa = 0;
    flt.bits.sign = 0;

    return flt.f;
  }

  NANOSTL_HOST_AND_DEVICE_QUAL
  static inline float quiet_NaN(void) {
    IEEE754Float flt;
    flt.bits.exponent = 255;
    flt.bits.mantissa = 1 << 22;
    flt.bits.sign = 0;

    return flt.f;
  }

  NANOSTL_HOST_AND_DEVICE_QUAL
  static inline float signaling_NaN(void) {
    IEEE754Float flt;
    flt.bits.exponent = 255;
    flt.bits.mantissa = 1;  // Set LSB at the moment
    flt.bits.sign = 0;

    return flt.f;
  }
  static const int digits10 = 6;
};

template <>
struct numeric_limits<double> {
  NANOSTL_HOST_AND_DEVICE_QUAL
  static inline double min(void) {
    return (2.2250738585072014e-308);
  }  // 0x1.0p-1022
  NANOSTL_HOST_AND_DEVICE_QUAL
  static inline double max(void) {
    return (1.7976931348623157e+308);
  }  // 0x1.fffffffffffffp102
  NANOSTL_HOST_AND_DEVICE_QUAL
  static inline double epsilon(void) {
    return (2.2204460492503131e-016);
  }  // 0x1.0p-52

  NANOSTL_HOST_AND_DEVICE_QUAL
  static inline double denorm_min(void) {
    IEEE754Double flt;
    flt.bits.sign = 0;
    flt.bits.exponent = 0;
    flt.bits.mantissa = 1;

    return flt.f;
  }

  NANOSTL_HOST_AND_DEVICE_QUAL
  static inline double infinity(void) {
    IEEE754Double flt;
    flt.bits.exponent = 2047;
    flt.bits.mantissa = 0;
    flt.bits.sign = 0;

    return flt.f;
  }

  NANOSTL_HOST_AND_DEVICE_QUAL
  static inline double quiet_NaN(void) {
    IEEE754Double flt;
    flt.bits.exponent = 2047;
    flt.bits.mantissa = 1ull << 51;
    flt.bits.sign = 0;

    return flt.f;
  }

  NANOSTL_HOST_AND_DEVICE_QUAL
  static inline double signaling_NaN(void) {
    IEEE754Double flt;
    flt.bits.exponent = 2047;
    flt.bits.mantissa = 1;  // Set LSB at the moment
    flt.bits.sign = 0;

    return flt.f;
  }
  static const int digits10 = 15;
};

}  // namespace nanostl

#ifdef __clang__
#pragma clang diagnostic pop
#endif

// #included from: nanoutility.h

#define NANOSTL_UTILITY_H_

// #included from: nanotype_traits.h

//
// Based on libcxx: Apache-2.0 WITH LLVM-exception
//
#define NANOSTL_TYPE_TRAITS_H_

namespace nanostl {

// helper class:
template <class T, T v>
struct integral_constant;
typedef integral_constant<bool, true> true_type;    // C++11
typedef integral_constant<bool, false> false_type;  // C++11

template <bool B>                                  // C++14
using bool_constant = integral_constant<bool, B>;  // C++14
typedef bool_constant<true> true_type;             // C++14
typedef bool_constant<false> false_type;           // C++14

// helper traits
template <bool, class T = void>
struct enable_if;
// template <bool, class T, class F> struct conditional;

// Primary classification traits:
template <class T>
struct is_void;
// template <class T> struct is_null_pointer;  // C++14
template <class T>
struct is_integral;
template <class T>
struct is_floating_point;
template <class T>
struct is_array;
template <class T>
struct is_pointer;
// template <class T> struct is_lvalue_reference;
// template <class T> struct is_rvalue_reference;
// template <class T> struct is_member_object_pointer;
// template <class T> struct is_member_function_pointer;
// template <class T> struct is_enum;
// template <class T> struct is_union;
// template <class T> struct is_class;
// template <class T> struct is_function;

    template <class T> struct remove_const;
    template <class T> struct remove_volatile;
 template <class T> struct remove_cv;

template <class T, class U> struct is_same;

template <bool b, class T = void>
using enable_if_t = typename enable_if<b, T>::type;  // C++14

template <class _Tp> struct _NANOSTL_TEMPLATE_VIS remove_const            {typedef _Tp type;};
template <class _Tp> struct _NANOSTL_TEMPLATE_VIS remove_const<const _Tp> {typedef _Tp type;};

template <class _Tp> struct _NANOSTL_TEMPLATE_VIS remove_volatile               {typedef _Tp type;};
template <class _Tp> struct _NANOSTL_TEMPLATE_VIS remove_volatile<volatile _Tp> {typedef _Tp type;};

template <class _Tp> struct _NANOSTL_TEMPLATE_VIS remove_cv
{typedef typename remove_volatile<typename remove_const<_Tp>::type>::type type;};

template <bool, class T> struct _NANOSTL_TEMPLATE_VIS enable_if {};
template <class _Tp> struct _NANOSTL_TEMPLATE_VIS enable_if<true, _Tp> {typedef _Tp type;};

typedef integral_constant<bool, true> true_type;
typedef integral_constant<bool, false> false_type;

template <class _Tp, _Tp __v>
struct _NANOSTL_TEMPLATE_VIS integral_constant
{
  static constexpr const _Tp      value = __v;
  typedef _Tp               value_type;
  typedef integral_constant type;
  constexpr operator value_type() const noexcept {return value;}
};

template <class _Tp, _Tp __v>
constexpr const _Tp integral_constant<_Tp, __v>::value;

template <class _Tp, class _Up> struct _NANOSTL_TEMPLATE_VIS is_same           : public false_type {};
template <class _Tp>            struct _NANOSTL_TEMPLATE_VIS is_same<_Tp, _Tp> : public true_type {};

template <class _Tp> struct __libcpp_is_floating_point              : public false_type {};
template <>          struct __libcpp_is_floating_point<float>       : public true_type {};
template <>          struct __libcpp_is_floating_point<double>      : public true_type {};
template <>          struct __libcpp_is_floating_point<long double> : public true_type {};

template <class _Tp> struct _NANOSTL_TEMPLATE_VIS is_floating_point
    : public __libcpp_is_floating_point<typename remove_cv<_Tp>::type> {};

}  // namespace nanostl

namespace nanostl {

template <class T1, class T2>
struct pair {
  T1 first;
  T2 second;
  pair() {}
  pair(const T1& a, const T2& b) : first(a), second(b) {}
};

template <class T1, class T2>
inline bool operator==(const pair<T1, T2>& x, const pair<T1, T2>& y) {
  return x.first == y.first && x.second == y.second;
}

template <class T1, class T2>
inline bool operator<(const pair<T1, T2>& x, const pair<T1, T2>& y) {
  return x.first < y.first || (!(y.first < x.first) && x.second < y.second);
}

template <class T1, class T2>
inline pair<T1, T2> make_pair(const T1& x, const T2& y) {
  return pair<T1, T2>(x, y);
}

// limited implementation of swap
template <class T>
inline void swap(T &a, T &b) noexcept
{
  T tmp;
  tmp = a;
  a = b;
  b = tmp;
}

//template <class T> typename add_rvalue_reference<T>::type declval() noexcept;

}  // namespace nanostl

#ifdef NANOSTL_DEBUG
#if !defined(__CUDACC__)
#include <iostream>
#endif
#endif

//
// Simple alternative implementation of std::string
// Implement `string' as `vector<char>`
// TODO(LTE): Support traits and allocator.
//

namespace nanostl {

template <class charT>
class basic_string {
 public:
  typedef unsigned long long size_type;

  typedef charT value_type;
  typedef charT &reference;
  typedef const charT &const_reference;
  typedef charT *pointer;
  typedef const charT *const_pointer;
  typedef pointer iterator;
  typedef const_pointer const_iterator;

  NANOSTL_HOST_AND_DEVICE_QUAL
  basic_string() {
    data_.resize(1);
    data_[0] = '\0';
  }

  NANOSTL_HOST_AND_DEVICE_QUAL
  basic_string(const basic_string &s) { data_ = s.data_; }

  NANOSTL_HOST_AND_DEVICE_QUAL
  basic_string(const charT *s) {
    data_.clear();
    while (s && (*s) != '\0') {
      data_.push_back(*s);
      s++;
    }
    data_.push_back('\0');
  }

  NANOSTL_HOST_AND_DEVICE_QUAL
  basic_string(const charT *first, const charT *last) {
    const char *s = first;
    while (s && (s <= last)) {
      data_.push_back(*s);
      s++;
    }
  }

  NANOSTL_HOST_AND_DEVICE_QUAL
  basic_string(const charT *s, size_type count) {
    for (size_type i = 0; i < count; i++) {
      data_.push_back(s[i]);
    }
  }

  NANOSTL_HOST_AND_DEVICE_QUAL
  bool empty() const { return data_.size() == 0; }

  NANOSTL_HOST_AND_DEVICE_QUAL
  size_type size() const {
    // -1 for '\0'
    return data_.size() - 1;
  }

  NANOSTL_HOST_AND_DEVICE_QUAL
  size_type length() const {
    // -1 for '\0'
    return data_.size() - 1;
  }

  NANOSTL_HOST_AND_DEVICE_QUAL
  void clear() { data_.clear();
    data_.resize(1);
    data_[0] = '\0';
  }

  NANOSTL_HOST_AND_DEVICE_QUAL
  const charT *c_str() const { return &data_.at(0); }

  NANOSTL_HOST_AND_DEVICE_QUAL
  char &at(size_type pos) { return data_[pos]; }

  NANOSTL_HOST_AND_DEVICE_QUAL
  const charT &at(size_type pos) const { return data_[pos]; }

  NANOSTL_HOST_AND_DEVICE_QUAL
  char &operator[](size_type pos) { return data_[pos]; }

  NANOSTL_HOST_AND_DEVICE_QUAL
  const charT &operator[](size_type pos) const { return data_[pos]; }

  NANOSTL_HOST_AND_DEVICE_QUAL
  int compare(const basic_string &str) const {
    return compare_(&data_[0], &str[0]);
  }

  NANOSTL_HOST_AND_DEVICE_QUAL
  int compare(const charT *s) const { return compare_(&data_[0], s); }

  NANOSTL_HOST_AND_DEVICE_QUAL
  iterator erase(iterator pos) { return data_.erase(pos); }

  NANOSTL_HOST_AND_DEVICE_QUAL
  basic_string operator+(const basic_string &s) const;

  NANOSTL_HOST_AND_DEVICE_QUAL
  basic_string &operator+=(const basic_string &s);

  NANOSTL_HOST_AND_DEVICE_QUAL
  basic_string &operator=(const basic_string &s) {
    this->data_ = s.data_;
    return (*this);
  }

  NANOSTL_HOST_AND_DEVICE_QUAL
  bool operator==(const basic_string &str) const { return compare(str) == 0; }

  NANOSTL_HOST_AND_DEVICE_QUAL
  bool operator==(const charT *s) const { return compare(s) == 0; }

  NANOSTL_HOST_AND_DEVICE_QUAL
  bool operator!=(const basic_string &str) const { return compare(str) != 0; }

  NANOSTL_HOST_AND_DEVICE_QUAL
  bool operator!=(const charT *s) const { return compare(s) != 0; }

  NANOSTL_HOST_AND_DEVICE_QUAL
  bool operator<(const basic_string &str) const { return compare(str) < 0; }

  NANOSTL_HOST_AND_DEVICE_QUAL
  bool operator<(const charT *s) const { return compare(s) < 0; }

  NANOSTL_HOST_AND_DEVICE_QUAL
  bool operator>(const basic_string &str) const { return compare(str) > 0; }

  NANOSTL_HOST_AND_DEVICE_QUAL
  bool operator>(const charT *s) const { return compare(s) > 0; }

 private:
  nanostl::vector<charT> data_;

  inline int compare_(const charT *p, const charT *q) const {
    while (*p && (*p == *q)) {
      p++;
      q++;
    }

    return *reinterpret_cast<const unsigned char *>(p) -
           *reinterpret_cast<const unsigned char *>(q);
  }
};

template <class charT>
basic_string<charT> basic_string<charT>::operator+(
    const basic_string<charT> &s) const {
  basic_string<charT> result(*this);
  result += s;
  return result;
}

template <class charT>
basic_string<charT> &basic_string<charT>::operator+=(
    const basic_string<charT> &s) {
  // remove '\0'
  if (data_.size() < 1) {
    // this should not be happen
  } else {
    data_.pop_back();
  }

  const_iterator first = s.data_.begin();
  const_iterator last = s.data_.end(); // this contains `\0`

  for (; first != last; ++first) {
#ifdef NANOSTL_DEBUG
    printf("first = %c\n", *first);
#endif
    data_.push_back(*first);
  }

#ifdef NANOSTL_DEBUG
  printf("data_ = %s\n", &data_.at(0));
#endif

  return (*this);
}

typedef basic_string<char> string;

NANOSTL_HOST_AND_DEVICE_QUAL
string to_string(int value);

NANOSTL_HOST_AND_DEVICE_QUAL
string to_string(unsigned int value);

NANOSTL_HOST_AND_DEVICE_QUAL
string to_string(int64_t value);

NANOSTL_HOST_AND_DEVICE_QUAL
string to_string(uint64_t value);

NANOSTL_HOST_AND_DEVICE_QUAL
string to_string(float value);

NANOSTL_HOST_AND_DEVICE_QUAL
string to_string(double value);

NANOSTL_HOST_AND_DEVICE_QUAL
float stof(const nanostl::string &str, nanostl::size_t *idx = nullptr);

NANOSTL_HOST_AND_DEVICE_QUAL
float stod(const nanostl::string &str, nanostl::size_t *idx = nullptr);

#if defined(NANOSTL_IMPLEMENTATION)
#ifndef NANOSTL_STRING_IMPLEMENTATION
#define NANOSTL_STRING_IMPLEMENTATION
#endif
#endif

#if defined(NANOSTL_STRING_IMPLEMENTATION)

NANOSTL_HOST_AND_DEVICE_QUAL
string to_string(int value) {
  // naiive implementation of base-10 int to ascii
  // based on https://www.techiedelight.com/implement-itoa-function-in-c/

  auto myreverse = [](char *buf, int i, int j) {
    while (i < j) {
      swap(buf[i++], buf[j--]);
    }
  };

  char buffer[numeric_limits<int>::digits10 + 2];  // +2 for sign and null

  int n = (value < 0) ? -value : value;  // abs
  int i = 0;
  int base = 10;
  while (n) {
    int r = n % base;

    if (r >= 10) {
      buffer[i++] = 'A' + (r - 10);  //
    } else {
      buffer[i++] = '0' + r;
    }

    n = n / base;
  }

  if (i == 0) {
    buffer[i++] = '0';
  }

  if ((value < 0) && (base == 10)) {
    buffer[i++] = '-';
  }

  buffer[i] = '\0';

  myreverse(buffer, 0, i - 1);

  return string(buffer);
}

NANOSTL_HOST_AND_DEVICE_QUAL
string to_string(int64_t value) {
  // naiive implementation of base-10 int to ascii
  // based on https://www.techiedelight.com/implement-itoa-function-in-c/

  auto myreverse = [](char *buf, int i, int j) {
    while (i < j) {
      swap(buf[i++], buf[j--]);
    }
  };

  char buffer[numeric_limits<int64_t>::digits10 + 2];  // +2 for sign and null

  int n = (value < 0) ? -value : value;  // abs
  int i = 0;
  int base = 10;
  while (n) {
    int r = n % base;

    if (r >= 10) {
      buffer[i++] = 'A' + (r - 10);  //
    } else {
      buffer[i++] = '0' + r;
    }

    n = n / base;
  }

  if (i == 0) {
    buffer[i++] = '0';
  }

  if ((value < 0) && (base == 10)) {
    buffer[i++] = '-';
  }

  buffer[i] = '\0';

  myreverse(buffer, 0, i - 1);

  return string(buffer);
}

// TODO: Move implementation to .cc and remove `static`
NANOSTL_HOST_AND_DEVICE_QUAL
string to_string(float value) {
  char buf[16];
  ryu::f2s_buffered(value, buf);

  return string(buf);
}

NANOSTL_HOST_AND_DEVICE_QUAL
string to_string(double value) {
  char buf[25];
  ryu::d2s_buffered(value, buf);

  return string(buf);
}

NANOSTL_HOST_AND_DEVICE_QUAL
float stof(const nanostl::string &str, nanostl::size_t *idx) {
  (void)idx;  // TODO(LTE):
  float value;
  ryu::RyuStatus ret = ryu::s2f_n(str.c_str(), str.size(), &value);

  if (ret != ryu::RYU_SUCCESS) {
    // TODO(LTE): Report an error
    return nanostl::numeric_limits<float>::signaling_NaN();
  }

  return value;
}

NANOSTL_HOST_AND_DEVICE_QUAL
float stod(const nanostl::string &str, nanostl::size_t *idx) {
  (void)idx;  // TODO(LTE):
  double value;
  ryu::RyuStatus ret = ryu::s2d_n(str.c_str(), str.size(), &value);

  if (ret != ryu::RYU_SUCCESS) {
    // TODO(LTE): Report an error
    return nanostl::numeric_limits<double>::signaling_NaN();
  }

  return value;
}
#endif

}  // namespace nanostl

// #included from: nanomap.h

#define NANOSTL_MAP_H_

#ifdef NANOSTL_DEBUG
#include <iostream>
#endif

//
// Simple alternative implementation of std::map
//

namespace nanostl {

#ifdef __clang__
#pragma clang diagnostic push
#if __has_warning("-Wzero-as-null-pointer-constant")
#pragma clang diagnostic ignored "-Wzero-as-null-pointer-constant"
#endif
#endif

typedef unsigned int priority_type;

// https://ja.wikipedia.org/wiki/Xorshift
static inline priority_type priority_rand() {
  static priority_type y = 2463534242;
  y = y ^ (y << 13);
  y = y ^ (y >> 17);
  return y = y ^ (y << 5);
}

// TODO(LTE): Support Comparator and Allocator.
template <class Key, class T>
class map {
 public:
  typedef Key key_type;
  typedef nanostl::pair<const Key, T> value_type;
  typedef value_type& reference;
  typedef const value_type& const_reference;
  typedef value_type* pointer;
  typedef const value_type* const_pointer;

  struct Node {
    value_type val;
    priority_type pri;
    Node* ch[2];  // left, right
    Node(value_type v) : val(v), pri(priority_rand()) { ch[0] = ch[1] = 0; }
    inline Key key() { return val.first; }
    inline T mapped() { return val.second; }
  };

  class iterator {
    map<Key, T>* mp;
    Node* p;

   public:
    NANOSTL_HOST_AND_DEVICE_QUAL
    iterator(map<Key, T>* _mp = 0, Node* _p = 0) : mp(_mp), p(_p) {}

    NANOSTL_HOST_AND_DEVICE_QUAL
    iterator& operator++() {
      // O(log n)
      p = mp->__upper_bound(mp->root, p->val.first);
      return *this;
    }

    NANOSTL_HOST_AND_DEVICE_QUAL
    reference operator*() const { return p->val; }

    NANOSTL_HOST_AND_DEVICE_QUAL
    pointer operator->() const { return &(p->val); }

    NANOSTL_HOST_AND_DEVICE_QUAL
    bool operator==(const iterator& rhs) const {
      if (rhs.isEnd() && this->isEnd()) return true;
      return *rhs == this->p->val;
    }

    NANOSTL_HOST_AND_DEVICE_QUAL
    bool operator!=(const iterator& rhs) const {
      if (rhs.isEnd() && this->isEnd())
        return false;
      else if (rhs.isEnd() || this->isEnd())
        return true;
      return *rhs != this->p->val;
    }

    NANOSTL_HOST_AND_DEVICE_QUAL
    bool isEnd() const { return p == 0; }
  };

  typedef const iterator const_iterator;

  NANOSTL_HOST_AND_DEVICE_QUAL
  map() { root = 0; }

  NANOSTL_HOST_AND_DEVICE_QUAL
  ~map() { __delete(root); }

  // accessors:

  NANOSTL_HOST_AND_DEVICE_QUAL
  iterator begin() { return iterator(this, root); }

  NANOSTL_HOST_AND_DEVICE_QUAL
  iterator end() { return iterator(this, 0); }

  NANOSTL_HOST_AND_DEVICE_QUAL
  const_iterator end() const { return iterator(this, 0); }

  NANOSTL_HOST_AND_DEVICE_QUAL
  bool empty() const { return !root; }

  NANOSTL_HOST_AND_DEVICE_QUAL
  T& operator[](const key_type& k) {
    return (*((insert(value_type(k, T()))).first)).second;
  }

  // insert/erase

  typedef pair<iterator, bool> pair_iterator_bool;

  NANOSTL_HOST_AND_DEVICE_QUAL
  pair_iterator_bool insert(const value_type& x) {
    pair<Node*, pair_iterator_bool> p = __insert(root, x);
    root = p.first;
    return p.second;
  }

  // map operations:

  NANOSTL_HOST_AND_DEVICE_QUAL
  const_iterator find(const key_type& key) const {
    Node* t = __find(root, key);
    return (!t) ? this->end() : iterator(this, t);
  }

  NANOSTL_HOST_AND_DEVICE_QUAL
  const_iterator upper_bound(const key_type& key) const {
    Node* t = __upper_bound(root, key);
    return (!t) ? this->end() : iterator(this, t);
  }

  // debug:

  void print() {
#ifdef NANOSTL_DEBUG
    __print(root);
#endif
  }

 private:
  Node* root;

  // b: the direction of rotation
  NANOSTL_HOST_AND_DEVICE_QUAL
  Node* __rotate(Node* t, int b) {
    Node* s = t->ch[1 - b];
    t->ch[1 - b] = s->ch[b];
    s->ch[b] = t;
    return s;  // return the upper node after the rotation
  }

  // {pointer to the root node of the subtree, {iterator to inserted/found
  // value, inserted or not}}
  NANOSTL_HOST_AND_DEVICE_QUAL
  pair<Node*, pair_iterator_bool> __insert(Node* t, const value_type& x) {
    if (!t) {
      Node* n = new Node(x);
      return make_pair(n, make_pair(iterator(this, n), true));
    }
    Key key = x.first;
    if (key == t->key()) {
      return make_pair(t, make_pair(iterator(this, t), false));
    }
    int b = key > t->key();
    pair<Node*, pair_iterator_bool> p = __insert(t->ch[b], x);
    t->ch[b] = p.first;
    if (t->pri > t->ch[b]->pri) t = __rotate(t, 1 - b);
    return make_pair(t, p.second);
  }

  NANOSTL_HOST_AND_DEVICE_QUAL
  Node* __find(Node* t, const key_type& key) const {
    return (!t || key == t->key()) ? t : __find(t->ch[key > t->key()], key);
  }

  NANOSTL_HOST_AND_DEVICE_QUAL
  Node* __upper_bound(Node* t, const key_type& key) const {
    if (!t) return 0;
    if (key < t->key()) {
      Node* s = __upper_bound(t->ch[0], key);
      return s ? s : t;
    }
    return __upper_bound(t->ch[1], key);
  }

  NANOSTL_HOST_AND_DEVICE_QUAL
  void __delete(Node* t) {
    if (!t) return;
    __delete(t->ch[0]);
    __delete(t->ch[1]);
    delete t;
  }

#ifdef NANOSTL_DEBUG
  // for debug
  void __print(Node* t) {
    if (!t) {
      std::cout << "[]" << std::endl;
      return;
    }
    // preorder
    std::cout << "[key = " << t->val.first << ", mapped = " << t->val.second
              << ", pri = " << t->pri << "]" << std::endl;
    __print(t->ch[0]);
    __print(t->ch[1]);
  }
#endif
};

#ifdef __clang__
#pragma clang diagnostic pop
#endif

}  // namespace nanostl

// #included from: nanoalgorithm.h

#define NANOSTL_ALGORITHM_H_

namespace nanostl {

template <class T>
const T& min(const T& a, const T& b) {
  return !(b < a) ? a : b;
}

template <class T>
const T& max(const T& a, const T& b) {
  return !(b > a) ? a : b;
}

template<class ForwardIt>
ForwardIt max_element(ForwardIt first, ForwardIt last)
{
    if (first == last) return last;

    ForwardIt largest = first;
    ++first;
    for (; first != last; ++first) {
        if (*largest < *first) {
            largest = first;
        }
    }
    return largest;
}

}  // namespace nanostl

// #included from: nanomath.h

#define NANOSTL_MATH_H_

//
// Implements some <cmath> functionality.
// WARNING: Implementation is approximation. Not IEEE-754 compatible, it looses
// some precision, don't work well depending on CPU's rounding-mode.
//

// we need to import the definition from math.h
//#define FP_NAN (0)
//#define FP_INFINITE (1)
//#define FP_ZERO (2)
//#define FP_SUBNORMAL (3)
//#define FP_NORMAL (4)
//#define NANOSTL_FP_UNKNOWN  (5)

namespace nanostl {

static inline bool __is_zero(float arg) {
  IEEE754Float flt;
  flt.f = arg;

  if ((flt.bits.mantissa == 0) && (flt.bits.exponent == 0)) {
    return true;
  }

  return false;
}

static inline bool __is_zero(double arg) {
  IEEE754Double flt;
  flt.f = arg;

  if ((flt.bits.mantissa == 0) && (flt.bits.exponent == 0)) {
    return true;
  }

  return false;
}

static inline bool __is_subnormal(float arg) {
  IEEE754Float flt;
  flt.f = arg;

  if ((flt.bits.mantissa != 0) && (flt.bits.exponent == 0)) {
    return true;
  }

  return false;
}

static inline bool __is_subnormal(double arg) {
  IEEE754Double flt;
  flt.f = arg;

  if ((flt.bits.mantissa != 0) && (flt.bits.exponent == 0)) {
    return true;
  }

  return false;
}

template <typename T>
static inline T fabs(T num) {
  // TODO(LTE): Handle +0 and -0 case correctly.
  // TODO(LTE): Handle +inf and -inf case correctly.

  if (num < static_cast<T>(0)) {
    return -num;
  }

  return num;
}

// https://stackoverflow.com/questions/8377412/ceil-function-how-can-we-implement-it-ourselves
// FIXME(LTE): Won't work for large float value.
template <typename T>
static inline T ceil(T num) {
  int inum = int(num);
  T diff = num - static_cast<T>(inum);
  if (fabs(diff) < nanostl::numeric_limits<T>::epsilon()) {
    return inum;
  }

  if (num > static_cast<T>(0)) {
    return inum + 1;
  } else {
    return inum;
  }
}

// https://stackoverflow.com/questions/5122993/floor-int-function-implementaton
template <typename T>
static inline T floor(T x) {
  if (x >= static_cast<T>(0)) {
    return int(x);
  } else {
    int y = int(x);
    if (fabs(static_cast<T>(y) - x) < nanostl::numeric_limits<T>::epsilon()) {
      return y;
    } else {
      return y - 1;
    }
  }
}

static inline bool isfinite(float x) {
  IEEE754Float flt;
  flt.f = x;

  bool ret = flt.bits.exponent != 255;
  return ret;
}

static inline bool isfinite(double x) {
  IEEE754Double flt;
  flt.f = x;

  bool ret = flt.bits.exponent != 2047;
  return ret;
}

static inline bool isinf(float x) {
  IEEE754Float flt;
  flt.f = x;

  bool ret = (flt.bits.exponent == 255) && (flt.bits.mantissa == 0);
  return ret;
}

static inline bool isinf(double x) {
  IEEE754Double flt;
  flt.f = x;

  bool ret = (flt.bits.exponent == 2047) && (flt.bits.mantissa == 0);
  return ret;
}

static inline bool isnan(float x) {
  IEEE754Float flt;
  flt.f = x;

  bool ret = (flt.bits.exponent == 255) && (flt.bits.mantissa != 0);
  return ret;
}

static inline bool isnan(double x) {
  IEEE754Double flt;
  flt.f = x;

  bool ret = (flt.bits.exponent == 2047) && (flt.bits.mantissa != 0);
  return ret;
}

static inline bool isnormal(float x) {
  IEEE754Float flt;
  flt.f = x;

  bool ret = (flt.bits.exponent != 0) && (flt.bits.exponent != 255);
  return ret;
}

static inline bool isnormal(double x) {
  IEEE754Double flt;
  flt.f = x;

  bool ret = (flt.bits.exponent != 0) && (flt.bits.exponent != 2047);
  return ret;
}

template <typename T>
static inline T fmin(T x, T y) {
  // https://en.cppreference.com/w/cpp/numeric/math/fmin
  // If one of the two arguments is NaN, the value of the other argument is returned
  // Only if both arguments are NaN, NaN is returned

  if (isnan(x) && isnan(y)) {
    // TODO(LTE): Consider signaling_NaN and quiet_NaN?
    return x;
  }

  if (isnan(x)) {
    return y;
  }

  if (isnan(y)) {
    return x;
  }

  return (x < y) ? x : y;
}

template <typename T>
static inline T fmax(T x, T y) {
  // https://en.cppreference.com/w/cpp/numeric/math/fmin
  // If one of the two arguments is NaN, the value of the other argument is returned
  // Only if both arguments are NaN, NaN is returned

  if (isnan(x) && isnan(y)) {
    // TODO(LTE): Consider signaling_NaN and quiet_NaN?
    return x;
  }

  if (isnan(x)) {
    return y;
  }

  if (isnan(y)) {
    return x;
  }

  return (x > y) ? x : y;
}

#if 0
template <typename T>
static inline int fpclassify(T arg) {
  if (isnan(arg)) {
    return FP_NAN;
  } else if (isinf(arg)) {
    return FP_INFINITE;
  } else if (__is_zero(arg)) {
    return FP_ZERO;
  } else if (__is_subnormal(arg)) {
    return FP_SUBNORMAL;
  } else if (isnormal(arg)) {
    return FP_NORMAL;
  } else {
    return NANOSTL_FP_UNKNOWN;
  }
}
#endif

template <typename T>
static inline T clamp(const T& a, const T& low_val, const T& high_val) {
  return nanostl::max(low_val, nanostl::min(high_val, a));
}

static inline float UintToFloat(const unsigned int ui) {
  IEEE754Float flt;
  flt.ui = ui;
  return flt.f;
}

static inline float IntToFloat(const int i) {
  IEEE754Float flt;
  flt.i = i;
  return flt.f;
}

static inline unsigned int FloatToUint(const float f) {
  IEEE754Float flt;
  flt.f = f;
  return flt.ui;
}

static inline int FloatToInt(const float f) {
  IEEE754Float flt;
  flt.f = f;
  return flt.i;
}

static inline float sqrt(const float x) {
  IEEE754Float flt;
  flt.f = x;
  if ((flt.bits.mantissa == 0) && (flt.bits.exponent == 0)) {
    // +0, -0
    return x;
  }

  if (flt.ui == 0x3f800000) {  // 1
    return 1.0f;               // +0
  }

  // -inf
  if ((x < 0.0f) && nanostl::isinf(x)) {
    return x;
  }

  if (x < 0.0f) {
    return nanostl::numeric_limits<float>::quiet_NaN();
  }

  // Faster sqrt using Sqrt2 descrived in:
  // https://www.codeproject.com/Articles/69941/Best-Square-Root-Method-Algorithm-Function-Precisi

  // TODO(LTE): Consider Big endian machine.

  const float xhalf = 0.5f * x;

  union  // get bits for floating value
  {
    float x;
    int i;
  } u;
  u.x = x;
  u.i = 0x5f3759df - (u.i >> 1);  // gives initial guess y0
  return x * u.x *
         (1.5f -
          xhalf * u.x * u.x);  // Newton step, repeating increases accuracy
}

static inline float copysign(const float x, const float y) {
  IEEE754Float flt_x;
  flt_x.f = x;

  IEEE754Float flt_y;
  flt_y.f = y;

  unsigned int x_abs = flt_x.ui & 0x7fffffff;
  unsigned int y_sign = flt_y.ui & 0x80000000;

  IEEE754Float flt;
  flt.ui = y_sign | x_abs;

  return flt.f;
}

// Following faster approximated math functions are based on OIIO fmath.h

//  Copyright 2008-2014 Larry Gritz and the other authors and contributors.
//  All Rights Reserved.
//
//  Redistribution and use in source and binary forms, with or without
//  modification, are permitted provided that the following conditions are
//  met:
//  * Redistributions of source code must retain the above copyright
//    notice, this list of conditions and the following disclaimer.
//  * Redistributions in binary form must reproduce the above copyright
//    notice, this list of conditions and the following disclaimer in the
//    documentation and/or other materials provided with the distribution.
//  * Neither the name of the software's owners nor the names of its
//    contributors may be used to endorse or promote products derived from
//    this software without specific prior written permission.
//  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
//  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
//  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
//  A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
//  OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
//  SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
//  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
//  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
//  THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
//  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
//  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
//
//  (This is the Modified BSD License)
//
//  A few bits here are based upon code from NVIDIA that was also released
//  under the same modified BSD license, and marked as:
//     Copyright 2004 NVIDIA Corporation. All Rights Reserved.
//
//  Some parts of this file were first open-sourced in Open Shading Language,
//  then later moved here. The original copyright notice was:
//     Copyright (c) 2009-2014 Sony Pictures Imageworks Inc., et al.
//
//  Many of the math functions were copied from or inspired by other
//  public domain sources or open source packages with compatible licenses.
//  The individual functions give references were applicable.

#define kM_1_PI (0.318309886183790671537767526745028724)
#define kM_PI_2 (1.57079632679489661923132169163975144)
#define kM_PI_4 (0.785398163397448309615660845819875721)
#define kM_LN2 (0.69314718055994530941723212145817656)
#define kM_LN10 (2.30258509299404568401799145468436421)

/// Fused multiply and add: (a*b + c)
static inline float madd(float a, float b, float c) { return a * b + c; }

/// Round to nearest integer, returning as an int.
static inline int fast_rint(float x) {
  // emulate rounding by adding/substracting 0.5
  return static_cast<int>(x + copysign(0.5f, x));
}

// TODO(LTE): Generate our own approx function using sollya
static inline float fast_exp2(const float& xval) {
  // clamp to safe range for final addition
  float x = clamp(xval, -126.0f, 126.0f);
  // range reduction
  int m = int(x);
  x -= m;
  x = 1.0f - (1.0f - x);  // crush denormals (does not affect max ulps!)
  // 5th degree polynomial generated with sollya
  // Examined 2247622658 values of exp2 on [-126,126]: 2.75764912 avg ulp diff,
  // 232 max ulp ulp histogram:
  //  0  = 87.81%
  //  1  =  4.18%
  float r = 1.33336498402e-3f;
  r = madd(x, r, 9.810352697968e-3f);
  r = madd(x, r, 5.551834031939e-2f);
  r = madd(x, r, 0.2401793301105f);
  r = madd(x, r, 0.693144857883f);
  r = madd(x, r, 1.0f);
  // multiply by 2 ^ m by adding in the exponent
  // NOTE: left-shift of negative number is undefined behavior
  unsigned int ri = FloatToUint(r);
  float _f = UintToFloat(ri + (static_cast<unsigned int>(m) << 23));
  return _f;
}

template <typename T>
static inline T exp(T x);

static inline float exp(float x) {
  // Examined 2237485550 values of exp on [-87.3300018,87.3300018]: 2.6666452
  // avg ulp diff, 230 max ulp

  return fast_exp2(x * static_cast<float>(1 / kM_LN2));
}

static inline float fast_log2(const float& xval) {
  // NOTE: clamp to avoid special cases and make result "safe" from large
  // negative values/nans
  float x = clamp(xval, nanostl::numeric_limits<float>::min(),
                  nanostl::numeric_limits<float>::max());
  // based on https://github.com/LiraNuna/glsl-sse2/blob/master/source/vec4.h
  unsigned bits = FloatToUint(x);
  int exponent = int(bits >> 23) - 127;
  float f = UintToFloat((bits & 0x007FFFFF) | 0x3f800000) - 1.0f;
  // Examined 2130706432 values of log2 on [1.17549435e-38,3.40282347e+38]:
  // 0.0797524457 avg ulp diff, 3713596 max ulp, 7.62939e-06 max error ulp
  // histogram:
  //  0  = 97.46%
  //  1  =  2.29%
  //  2  =  0.11%
  float f2 = f * f;
  float f4 = f2 * f2;
  float hi = madd(f, -0.00931049621349f, 0.05206469089414f);
  float lo = madd(f, 0.47868480909345f, -0.72116591947498f);
  hi = madd(f, hi, -0.13753123777116f);
  hi = madd(f, hi, 0.24187369696082f);
  hi = madd(f, hi, -0.34730547155299f);
  lo = madd(f, lo, 1.442689881667200f);
  return ((f4 * hi) + (f * lo)) + exponent;
}

static inline float log(const float& x) {
  IEEE754Float flt;
  flt.f = x;
  if ((flt.bits.mantissa == 0) && (flt.bits.exponent == 0)) {
    // +0, -0
    return -nanostl::numeric_limits<float>::infinity();
  }

  if (flt.ui == 0x3f800000) {  // 1
    return 0.0f;               // +0
  }

  if (x < 0.0f) {
    return nanostl::numeric_limits<float>::infinity();
  }

  // Examined 2130706432 values of logf on [1.17549435e-38,3.40282347e+38]:
  // 0.313865375 avg ulp diff, 5148137 max ulp, 7.62939e-06 max error
  return fast_log2(x) * static_cast<float>(kM_LN2);
}

static inline float log10(const float& x) {
  IEEE754Float flt;
  flt.f = x;

  if ((flt.bits.mantissa == 0) && (flt.bits.exponent == 0)) {
    // +0, -0
    return -nanostl::numeric_limits<float>::infinity();
  }

  if (flt.ui == 0x3f800000) {  // 1
    return 0.0f;               // +0
  }

  if (x < 0.0f) {
    return nanostl::numeric_limits<float>::infinity();
  }

  // Examined 2130706432 values of log10f on [1.17549435e-38,3.40282347e+38]:
  // 0.631237033 avg ulp diff, 4471615 max ulp, 3.8147e-06 max error
  return fast_log2(x) * static_cast<float>(kM_LN2 / kM_LN10);
}

// fast_safe_pow
static inline float pow(float x, float y) {
  if (fabs(y) < nanostl::numeric_limits<float>::epsilon())
    return 1.0f;  // x^0=1
  if (fabs(x) < nanostl::numeric_limits<float>::epsilon())
    return 0.0f;  // 0^y=0
  // be cheap & exact for special case of squaring and identity
  if (y == 1.0f) return x;
  if (y == 2.0f) {
    return nanostl::min(x * x, nanostl::numeric_limits<float>::max());
  }
  float sign = 1.0f;
  if (x < 0) {
    // if x is negative, only deal with integer powers
    // powf returns NaN for non-integers, we will return 0 instead
    int ybits = FloatToInt(y) & 0x7fffffff;
    if (ybits >= 0x4b800000) {
      // always even int, keep positive
    } else if (ybits >= 0x3f800000) {
      // bigger than 1, check
      int k = (ybits >> 23) - 127;   // get exponent
      int j = ybits >> (23 - k);     // shift out possible fractional bits
      if ((j << (23 - k)) == ybits)  // rebuild number and check for a match
        sign = IntToFloat(0x3f800000 | (j << 31));  // +1 for even, -1 for odd
      else
        return 0.0f;  // not integer
    } else {
      return 0.0f;  // not integer
    }
  }
  return sign * fast_exp2(y * fast_log2(fabs(x)));
}

static inline float sin(float x) {
  // very accurate argument reduction from SLEEF
  // starts failing around x=262000
  // Results on: [-2pi,2pi]
  // Examined 2173837240 values of sin: 0.00662760244 avg ulp diff, 2 max
  // ulp, 1.19209e-07 max error
  int q = fast_rint(x * float(kM_1_PI));
  float qf = q;
  x = madd(qf, -0.78515625f * 4, x);
  x = madd(qf, -0.00024187564849853515625f * 4, x);
  x = madd(qf, -3.7747668102383613586e-08f * 4, x);
  x = madd(qf, -1.2816720341285448015e-12f * 4, x);
  x = float(kM_PI_2) - (float(kM_PI_2) - x);  // crush denormals
  float s = x * x;
  if ((q & 1) != 0) x = -x;
  // this polynomial approximation has very low error on [-pi/2,+pi/2]
  // 1.19209e-07 max error in total over [-2pi,+2pi]
  float u = 2.6083159809786593541503e-06f;
  u = madd(u, s, -0.0001981069071916863322258f);
  u = madd(u, s, +0.00833307858556509017944336f);
  u = madd(u, s, -0.166666597127914428710938f);
  u = madd(s, u * x, x);
  // For large x, the argument reduction can fail and the polynomial can be
  // evaluated with arguments outside the valid internal. Just clamp the bad
  // values away (setting to 0.0f means no branches need to be generated).
  if (fabs(u) > 1.0f) u = 0.0f;
  return u;
}

static inline float cos(float x) {
  // same argument reduction as fast_sin
  int q = fast_rint(x * float(kM_1_PI));
  float qf = q;
  x = madd(qf, -0.78515625f * 4, x);
  x = madd(qf, -0.00024187564849853515625f * 4, x);
  x = madd(qf, -3.7747668102383613586e-08f * 4, x);
  x = madd(qf, -1.2816720341285448015e-12f * 4, x);
  x = float(kM_PI_2) - (float(kM_PI_2) - x);  // crush denormals
  float s = x * x;
  // polynomial from SLEEF's sincosf, max error is
  // 4.33127e-07 over [-2pi,2pi] (98% of values are "exact")
  float u = -2.71811842367242206819355e-07f;
  u = madd(u, s, +2.47990446951007470488548e-05f);
  u = madd(u, s, -0.00138888787478208541870117f);
  u = madd(u, s, +0.0416666641831398010253906f);
  u = madd(u, s, -0.5f);
  u = madd(u, s, +1.0f);
  if ((q & 1) != 0) u = -u;
  if (fabs(u) > 1.0f) u = 0.0f;
  return u;
}

// NOTE: this approximation is only valid on [-8192.0,+8192.0], it starts
// becoming really poor outside of this range because the reciprocal amplifies
// errors
static inline float tan(float x) {
  // derived from SLEEF implementation
  // note that we cannot apply the "denormal crush" trick everywhere because
  // we sometimes need to take the reciprocal of the polynomial
  int q = fast_rint(x * float(2 * kM_1_PI));
  float qf = q;
  x = madd(qf, -0.78515625f * 2, x);
  x = madd(qf, -0.00024187564849853515625f * 2, x);
  x = madd(qf, -3.7747668102383613586e-08f * 2, x);
  x = madd(qf, -1.2816720341285448015e-12f * 2, x);
  if ((q & 1) == 0)
    x = float(kM_PI_4) -
        (float(kM_PI_4) -
         x);  // crush denormals (only if we aren't inverting the result later)
  float s = x * x;
  float u = 0.00927245803177356719970703f;
  u = madd(u, s, 0.00331984995864331722259521f);
  u = madd(u, s, 0.0242998078465461730957031f);
  u = madd(u, s, 0.0534495301544666290283203f);
  u = madd(u, s, 0.133383005857467651367188f);
  u = madd(u, s, 0.333331853151321411132812f);
  u = madd(s, u * x, x);
  if ((q & 1) != 0) u = -1.0f / u;
  return u;
}

static inline float sinh(float x) {
  float a = fabs(x);
  if (a > 1.0f) {
    // Examined 53389559 values of sinh on [1,87.3300018]: 33.6886442 avg ulp
    // diff, 178 max ulp
    float e = exp(a);
    return copysign(0.5f * e - 0.5f / e, x);
  } else {
    a = 1.0f - (1.0f - a);  // crush denorms
    float a2 = a * a;
    // degree 7 polynomial generated with sollya
    // Examined 2130706434 values of sinh on [-1,1]: 1.19209e-07 max error
    float r = 2.03945513931e-4f;
    r = madd(r, a2, 8.32990277558e-3f);
    r = madd(r, a2, 0.1666673421859f);
    r = madd(r * a, a2, a);
    return copysign(r, x);
  }
}

static inline float cosh(float x) {
  // Examined 2237485550 values of cosh on [-87.3300018,87.3300018]: 1.78256726
  // avg ulp diff, 178 max ulp
  float e = exp(fabs(x));
  return 0.5f * e + 0.5f / e;
}

static inline float tanh(float x) {
  // Examined 4278190080 values of tanh on
  // [-3.40282347e+38,3.40282347e+38]: 3.12924e-06 max error NOTE: ulp error is
  // high because of sub-optimal handling around the origin
  float e = exp(2.0f * fabs(x));
  return copysign(1 - 2 / (1 + e), x);
}

static inline float erf(float x) {
  // Examined 1082130433 values of erff on [0,4]: 1.93715e-06 max error
  // Abramowitz and Stegun, 7.1.28
  const float a1 = 0.0705230784f;
  const float a2 = 0.0422820123f;
  const float a3 = 0.0092705272f;
  const float a4 = 0.0001520143f;
  const float a5 = 0.0002765672f;
  const float a6 = 0.0000430638f;
  const float a = fabs(x);
  const float b = 1.0f - (1.0f - a);  // crush denormals
  const float r =
      madd(madd(madd(madd(madd(madd(a6, b, a5), b, a4), b, a3), b, a2), b, a1),
           b, 1.0f);
  const float s = r * r;  // ^2
  const float t = s * s;  // ^4
  const float u = t * t;  // ^8
  const float v = u * u;  // ^16
  return copysign(1.0f - 1.0f / v, x);
}

// Fast cube root (performs better that using fast_pow's above with y=1/3)
static inline float cbrt(float x) {
  float x0 = fabs(x);
  // from hacker's delight
  float a = IntToFloat(0x2a5137a0 + FloatToInt(x0) / 3);  // Initial guess.
  // Examined 14272478 values of cbrt on
  // [-9.99999935e-39,9.99999935e-39]: 8.14687e-14 max error Examined 2131958802
  // values of cbrt on [9.99999935e-39,3.40282347e+38]: 2.46930719 avg ulp diff,
  // 12 max ulp
  a = 0.333333333f * (2.0f * a + x0 / (a * a));  // Newton step.
  a = 0.333333333f * (2.0f * a + x0 / (a * a));  // Newton step again.
  a = (fabs(x0) < nanostl::numeric_limits<float>::epsilon()) ? 0
                                                             : a;  // Fix 0 case
  return copysign(a, x);
}

static inline float erfc(float x) {
  // Examined 2164260866 values of erfcf on [-4,4]: 1.90735e-06 max error
  // ulp histogram:
  //   0  = 80.30%
  return 1.0f - erf(x);
}

static inline float ierf(float x) {
  // from: Approximating the erfinv function by Mike Giles
  // to avoid trouble at the limit, clamp input to 1-eps
  float a = fabs(x);
  if (a > 0.99999994f) a = 0.99999994f;
  float w = -log((1.0f - a) * (1.0f + a)), p;
  if (w < 5.0f) {
    w = w - 2.5f;
    p = 2.81022636e-08f;
    p = madd(p, w, 3.43273939e-07f);
    p = madd(p, w, -3.5233877e-06f);
    p = madd(p, w, -4.39150654e-06f);
    p = madd(p, w, 0.00021858087f);
    p = madd(p, w, -0.00125372503f);
    p = madd(p, w, -0.00417768164f);
    p = madd(p, w, 0.246640727f);
    p = madd(p, w, 1.50140941f);
  } else {
    w = sqrt(w) - 3.0f;
    p = -0.000200214257f;
    p = madd(p, w, 0.000100950558f);
    p = madd(p, w, 0.00134934322f);
    p = madd(p, w, -0.00367342844f);
    p = madd(p, w, 0.00573950773f);
    p = madd(p, w, -0.0076224613f);
    p = madd(p, w, 0.00943887047f);
    p = madd(p, w, 1.00167406f);
    p = madd(p, w, 2.83297682f);
  }
  return p * x;
}

// -- End OIIO fmath.h
// ----------------------------------------------------------------------------

}  // namespace nanostl

// #included from: nanoiostream.h

#define NANOSTL_IOSTREAM_H_

#ifdef NANOSTL_DEBUG
#include <stdio.h>
#endif

// #included from: nanoiosfwd.h

#define NANOSTL_IOSFWD_H_

namespace nanostl {

template <class CharT>
struct char_traits;

template <>
struct char_traits<char>;
// template<> struct char_traits<char8_t>;
template <>
struct char_traits<char16_t>;
template <>
struct char_traits<char32_t>;
template <>
struct char_traits<wchar_t>;

template <class charT, class traits = char_traits<charT> >
class basic_streambuf;
template <class _CharT, class _Traits = char_traits<_CharT> >
class basic_ostream;

typedef basic_streambuf<char> streambuf;
typedef basic_ostream<char> ostream;

template <class _State>             class fpos;

// TODO: Use mbstate_t
typedef fpos<long long>    streampos;

}  // namespace nanostl

// #included from: nanoios.h

#define NANOSTL_IOS_H_

// #included from: __string
// based on libcxx
#define NANOSTL___STRING_H_

namespace nanostl {

// streamoff is unspeficied, but usually long long
typedef long long streamoff;

template <class _CharT>
struct char_traits
{
    typedef _CharT    char_type;
    typedef int       int_type;
    typedef streamoff off_type;
    typedef streampos pos_type;
    //typedef mbstate_t state_type;

    // TODO: Implement
};

template <>
struct char_traits<char>
{
    typedef char      char_type;
    typedef int       int_type;
    typedef streamoff off_type;
    typedef streampos pos_type;
    //typedef mbstate_t state_type;

    // TODO: Implement
};

} // namespace nanostl

namespace nanostl {

// ptrdiff_t is implementation dependent, but usually `long int`(int64 for 64bit system)
typedef long int streamsize;

class ios_base {
 public:
  typedef unsigned int fmtflags;
  static const fmtflags boolalpha = 0x0001;
  static const fmtflags dec = 0x0002;
  static const fmtflags fixed = 0x0004;
  static const fmtflags hex = 0x0008;
  static const fmtflags internal = 0x0010;
  static const fmtflags left = 0x0020;
  static const fmtflags oct = 0x0040;
  static const fmtflags right = 0x0080;
  static const fmtflags scientific = 0x0100;
  static const fmtflags showbase = 0x0200;
  static const fmtflags showpoint = 0x0400;
  static const fmtflags showpos = 0x0800;
  static const fmtflags skipws = 0x1000;
  static const fmtflags unitbuf = 0x2000;
  static const fmtflags uppercase = 0x4000;
  static const fmtflags adjustfield = left | right | internal;
  static const fmtflags basefield = dec | oct | hex;
  static const fmtflags floatfield = scientific | fixed;

  typedef unsigned int iostate;
  static const iostate badbit = 0x1;
  static const iostate eofbit = 0x2;
  static const iostate failbit = 0x4;
  static const iostate goodbit = 0x0;

  typedef unsigned int openmode;
  static const openmode app = 0x01;
  static const openmode ate = 0x02;
  static const openmode binary = 0x04;
  static const openmode in = 0x08;
  static const openmode out = 0x10;
  static const openmode trunc = 0x20;

  enum seekdir { beg, cur, end };

  class Init;

  // destructor
  virtual ~ios_base();

  inline bool good() const;
  inline bool eof() const;
  inline bool fail() const;
  inline bool bad() const;

private:
    ios_base(const ios_base&) = delete;
    ios_base& operator=(const ios_base&) = delete;

protected:
    ios_base() {
               }

};

// Based on libcxx ----------------------------

template <class _CharT, class _Traits>
class basic_ios
    : public ios_base
{
public:
    // types:
    typedef _CharT char_type;
    typedef _Traits traits_type;

    typedef typename traits_type::int_type int_type;
    //typedef typename traits_type::pos_type pos_type; // TODO
    typedef typename traits_type::off_type off_type;

    static_assert((is_same<_CharT, typename traits_type::char_type>::value),
                  "traits_type::char_type must be the same type as CharT");

    explicit operator bool() const {return !fail();}

    inline bool operator!() const    {return  fail();}
    //inline iostate rdstate() const   {return ios_base::rdstate();}
    //inline void clear(iostate __state = goodbit) {ios_base::clear(__state);}
    //inline void setstate(iostate __state) {ios_base::setstate(__state);}
    inline bool good() const {return ios_base::good();}
    inline bool eof() const  {return ios_base::eof();}
    inline bool fail() const {return ios_base::fail();}
    inline bool bad() const  {return ios_base::bad();}

};

class ios_base::Init
{
public:
    Init();
    ~Init();
};

}  // namespace nanostl

// #included from: nanosstream.h

#define NANOSTL_SSTREAM_H_

// #included from: nanostreambuf.h

#define NANOSTL_STREAMBUF_H_

namespace nanostl {

template <class _CharT, class _Traits>
class basic_streambuf {
 public:
  // types:
  typedef _CharT char_type;
  typedef _Traits traits_type;
  typedef typename traits_type::int_type int_type;
  typedef typename traits_type::pos_type pos_type;
  typedef typename traits_type::off_type off_type;

  static_assert((is_same<_CharT, typename traits_type::char_type>::value),
                "traits_type::char_type must be the same type as CharT");

  virtual ~basic_streambuf();

 protected:
  basic_streambuf();
  basic_streambuf(const basic_streambuf& __rhs);
  basic_streambuf& operator=(const basic_streambuf& __rhs);
  void swap(basic_streambuf& __rhs);
};

//extern template class basic_streambuf<char>;

//typedef basic_streambuf<char> streambuf;

}  // namespace nanostl

namespace nanostl {

// Work in progress.
// TODO(LTE): Implement
// TODO(LTE): Inherit ostream
#if 1
class stringstream
{
  typedef unsigned long long size_type;

  public:
    NANOSTL_HOST_AND_DEVICE_QUAL
    stringstream& operator=(const stringstream&) = delete; // disable copy

    NANOSTL_HOST_AND_DEVICE_QUAL
    stringstream& operator=(stringstream&& other) {
      str_ = other.str_;
      other.str_ = string();

      return (*this);
    }

    NANOSTL_HOST_AND_DEVICE_QUAL
    stringstream() {}

    NANOSTL_HOST_AND_DEVICE_QUAL
    ~stringstream() {}

    // FIXME(LTE): Signature is different from STL spec. take the reference. drop const
    NANOSTL_HOST_AND_DEVICE_QUAL
    string &str() {
      return str_;
    }

    // TODO(LTE): Use stringbuf or streambuf
    NANOSTL_HOST_AND_DEVICE_QUAL
    stringstream& operator<<(const nanostl::string &s) {

      str_ += s;
      return (*this);
    }

    // TODO(LTE): Inherit ios
    void clear() {
      str_ = string();
    }

 private:

  NANOSTL_HOST_AND_DEVICE_QUAL
  size_type size() const { return str_.size(); }

 private:
  nanostl::string str_;
};
#endif

}  // namespace nanostl

// #included from: __nullptr
// -*- C++ -*-
//===--------------------------- __nullptr --------------------------------===//
//
// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
// See https://llvm.org/LICENSE.txt for license information.
// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
//
//===----------------------------------------------------------------------===//

#ifndef NANOSTL__NULLPTR
#define NANOSTL__NULLPTR

//#include <__config>

namespace nanostl {

struct nullptr_t
{
    void* __lx;

    struct __nat {int __for_bool_;};

    inline constexpr nullptr_t() : __lx(0) {}
    inline constexpr nullptr_t(int __nat::*) : __lx(0) {}

    inline constexpr operator int __nat::*() const {return 0;}

    template <class _Tp>
        inline constexpr
        operator _Tp* () const {return 0;}

    template <class _Tp, class _Up>
        inline
        operator _Tp _Up::* () const {return 0;}

    friend inline constexpr bool operator==(nullptr_t, nullptr_t) {return true;}
    friend inline constexpr bool operator!=(nullptr_t, nullptr_t) {return false;}
};

inline constexpr nullptr_t __get_nullptr_t() {return nullptr_t(0);}

//#define nullptr _VSTD::__get_nullptr_t()
#define nullptr nanostl::__get_nullptr_t()

}

#endif  // NANOSTL__NULLPTR
namespace nanostl {

// Based on libcxx ----------------------

template <class _CharT, class _Traits>
class basic_ostream
    : virtual public basic_ios<_CharT, _Traits>
{
public:
    // types (inherited from basic_ios (27.5.4)):
    typedef _CharT                         char_type;
    typedef _Traits                        traits_type;
    typedef typename traits_type::int_type int_type;
    typedef typename traits_type::pos_type pos_type;
    typedef typename traits_type::off_type off_type;

    basic_ostream& operator<<(bool __n);
    basic_ostream& operator<<(short __n);
    basic_ostream& operator<<(unsigned short __n);
    basic_ostream& operator<<(int __n);
    basic_ostream& operator<<(unsigned int __n);
    //basic_ostream& operator<<(long __n);
    //basic_ostream& operator<<(unsigned long __n);
    basic_ostream& operator<<(long long __n);
    basic_ostream& operator<<(unsigned long long __n);
    basic_ostream& operator<<(float __f);
    basic_ostream& operator<<(double __f);
    basic_ostream& operator<<(long double __f);
    basic_ostream& operator<<(const void* __p);

    basic_ostream& operator<<(basic_streambuf<char_type, traits_type>* __sb);

    inline
    basic_ostream& operator<<(nullptr_t)
    { return *this << "nullptr"; }

    // 27.7.2.7 Unformatted output:
    basic_ostream& put(char_type __c);
    basic_ostream& write(const char_type* __s, streamsize __n);
    basic_ostream& flush();

protected:
    // TODO: Uncomment
    //basic_ostream() {}

private:
    // FIXME
    stringstream _ss;

};

template <class _CharT, class _Traits>
basic_ostream<_CharT, _Traits>&
basic_ostream<_CharT, _Traits>::operator<<(bool __n)
{

  _ss << nanostl::to_string(__n);

  return *this;
}

template <class _CharT, class _Traits>
basic_ostream<_CharT, _Traits>&
basic_ostream<_CharT, _Traits>::operator<<(short __n)
{

  _ss << nanostl::to_string(__n);

  return *this;
}

template <class _CharT, class _Traits>
basic_ostream<_CharT, _Traits>&
basic_ostream<_CharT, _Traits>::operator<<(unsigned short __n)
{

  _ss << nanostl::to_string(__n);

  return *this;
}

template <class _CharT, class _Traits>
basic_ostream<_CharT, _Traits>&
basic_ostream<_CharT, _Traits>::operator<<(int __n)
{

  _ss << nanostl::to_string(__n);

  return *this;
}

template <class _CharT, class _Traits>
basic_ostream<_CharT, _Traits>&
basic_ostream<_CharT, _Traits>::operator<<(unsigned int __n)
{

  _ss << nanostl::to_string(__n);

  return *this;
}

template <class _CharT, class _Traits>
basic_ostream<_CharT, _Traits>&
basic_ostream<_CharT, _Traits>::operator<<(long long __n)
{

  _ss << nanostl::to_string(__n);

  return *this;
}

template <class _CharT, class _Traits>
basic_ostream<_CharT, _Traits>&
basic_ostream<_CharT, _Traits>::operator<<(unsigned long long __n)
{

  _ss << nanostl::to_string(__n);

  return *this;
}

template <class _CharT, class _Traits>
basic_ostream<_CharT, _Traits>&
basic_ostream<_CharT, _Traits>::operator<<(float __n)
{

  _ss << nanostl::to_string(__n);

  return *this;
}

template <class _CharT, class _Traits>
basic_ostream<_CharT, _Traits>&
basic_ostream<_CharT, _Traits>::operator<<(double __n)
{

  _ss << nanostl::to_string(__n);

  return *this;
}

template<>
basic_ostream<char, nanostl::char_traits<char>>&
basic_ostream<char, nanostl::char_traits<char>>::operator<<(const void *__n)
{
  // FIXME: Assume const char *
  string str = nanostl::string(static_cast<const char *>(__n));
  _ss << str;

#ifdef NANOSTL_DEBUG
  printf("n : %s\n", str.c_str());
  printf("string: %s\n", _ss.str().c_str());
#endif
  return *this;
}

// --------------------------------------

// Need to link with iostream.cc
extern ostream cout;
extern ostream cerr;

} // namespace nanostl

#ifdef NANOSTL_IMPLEMENTATION
#ifndef NANOSTL_IOSTREAM_IMPLEMENTATION
#define NANOSTL_IOSTREAM_IMPLEMENTATION
#endif
#endif

#ifdef NANOSTL_IOSTREAM_IMPLEMENTATION

#ifndef NANOSTL_NO_IO
#include <stdio.h>
#endif

namespace nanostl {

#ifndef NANOSTL_NO_IO

#if __has_feature(cxx_alignas)
#define _ALIGNAS_TYPE(x) alignas(x)
#define _ALIGNAS(x) alignas(x)
#else
#error TODO
#define _ALIGNAS_TYPE(x) __attribute__((__aligned__(_LIBCPP_ALIGNOF(x))))
#define _ALIGNAS(x) __attribute__((__aligned__(x)))
#endif

ios_base::~ios_base() {
  // TODO
}

template<>
ostream& ostream::flush() {
  printf("%s", _ss.str().c_str());

  _ss.clear();

  return (*this);
}

//_ALIGNAS_TYPE (ostream) char cout[sizeof(ostream)];
ostream cout; // fixme

// from libcxx
class DoIOSInit {
 public:
  DoIOSInit();
  ~DoIOSInit();
};

DoIOSInit::DoIOSInit() {
  // force_locale_initialization();

#ifndef _LIBCPP_HAS_NO_STDOUT
  // ostream* cout_ptr = ::new(cout) ostream(::new(__cout)
  // __stdoutbuf<char>(stdout, &mb_cout));
#endif
  // ostream* cerr_ptr = ::new(cerr) ostream(::new(__cerr)
  // __stdoutbuf<char>(stderr, &mb_cerr));
  //                    ::new(clog) ostream(cerr_ptr->rdbuf());

  //_VSTD::unitbuf(*cerr_ptr);
#ifndef _LIBCPP_HAS_NO_STDOUT
  // cerr_ptr->tie(cout_ptr);
#endif
}

DoIOSInit::~DoIOSInit(){
#ifndef _LIBCPP_HAS_NO_STDOUT
// ostream* cout_ptr = reinterpret_cast<ostream*>(cout);
// wostream* wcout_ptr = reinterpret_cast<wostream*>(wcout);
// cout_ptr->flush();
// wcout_ptr->flush();
#endif

    // ostream* clog_ptr = reinterpret_cast<ostream*>(clog);
    // wostream* wclog_ptr = reinterpret_cast<wostream*>(wclog);
    // clog_ptr->flush();
    // wclog_ptr->flush();
}

ios_base::Init::Init() {
  static DoIOSInit init_the_streams;  // gets initialized once
}

ios_base::Init::~Init() {}

// compiler specific way
//__attribute__ ((__visibility__("hidden"))) ios_base::Init __start_std_streams
//__attribute__((init_priority(101)));

// Invoke Init() before main()
ios_base::Init __start_std_streams;

#else
#error TODO
#endif

}
#endif

#endif // NANOSTL_H_
#endif // NANOSTL_SINGLE_INCLUDE_H_

